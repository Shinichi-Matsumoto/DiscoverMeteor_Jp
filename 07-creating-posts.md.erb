---
title: Creating Posts
slug: creating-posts
date: 0007/01/01
number: 7
contents: Learn how to submit a post client-side.|Implement a simple security check.|Restrict access to the post submit form.|Learn to use a server-side Method for added security.
paragraphs: 60
---

We've seen how easy it is to create posts via the console, 
using the Posts.insert database call,
but we can't expect our users to open the console to create a new post.
私たちはコンソール経由でデータベースを呼び出すPosts.insertを使うことで、いかに簡単に投稿を作るのか見てきました。
しかし私たちはユーザーがコンソールを開いて新しい投稿をすることを見込むことはできません。

Eventually, we'll need to build some kind of user interface to let our users post new stories to our app.
最終的に、私たちは　ユーザーがアプリに新しい（ stories？）を投稿できるように　ある種のユーザーインターフェースを作る必要があります。

### Building The New Post Page

We begin by defining a route for our new page:
新しいページにルートを定義する（？？？）ことから始めていきます。

~~~js
Router.configure({
  layoutTemplate: 'layout',
  loadingTemplate: 'loading',
  waitOn: function() { return Meteor.subscribe('posts'); }
});

Router.map(function() {
  this.route('postsList', {path: '/'});
  
  this.route('postPage', {
    path: '/posts/:_id',
    data: function() { return Posts.findOne(this.params._id); }
  });
  
  this.route('postSubmit', {
    path: '/submit'
  });
});
~~~
<%= caption "lib/router.js" %>
<%= highlight "13~15" %>

We're using the router's data function to set the postPage template's data context. 
Remember that whatever we put into the data context will be available as this inside the template helpers.
私たちはpostPageテンプレートのデータコンテキストを設定するために　ルーターのdata関数を使っています。
私たちがデータコンテキストに入れるものは　テンプレートヘルパー内で　使うことができることを覚えておきましょう。（？？？）　

### Adding A Link To The Header

With that route defined, we can now add a link to our submit page in our header:
ルートが定義されると、私たちは　ヘッダーにページを（submit？）するための　リンクを入れることができます。

~~~html
<template name="header">
  <header class="navbar">
    <div class="navbar-inner">
      <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </a>
      <a class="brand" href="{{pathFor 'postsList'}}">Microscope</a>
      <div class="nav-collapse collapse">
        <ul class="nav">
          <li><a href="{{pathFor 'postSubmit'}}">New</a></li>
        </ul>
        <ul class="nav pull-right">
          <li>{{loginButtons}}</li>
        </ul>
      </div>
    </div>
  </header>
</template>
~~~
<%= caption "client/views/includes/header.html" %>
<%= highlight "11~16" %>

Setting up our route means that if a user browses to the /submit URL,
Meteor will display the postSubmit template. So let's write that template:
ルートを設定するということは　ユーザーが　 /submit URLのウェブページを見るなら
Meteorが　postSubmitテンプレートを表示するということを意味しています。では、テンプレートを書いていきましょう。

~~~html
<template name="postSubmit">
  <form class="main">
    <div class="control-group">
        <label class="control-label" for="url">URL</label>
        <div class="controls">
            <input name="url" type="text" value="" placeholder="Your URL"/>
        </div>
    </div>

    <div class="control-group">
        <label class="control-label" for="title">Title</label>
        <div class="controls">
            <input name="title" type="text" value="" placeholder="Name your post"/>
        </div>
    </div>

    <div class="control-group">
        <label class="control-label" for="message">Message</label>
        <div class="controls">
            <textarea name="message" type="text" value=""/>
        </div>
    </div> 

    <div class="control-group">
        <div class="controls">
            <input type="submit" value="Submit" class="btn btn-primary"/>
        </div>
    </div>
  </form>
</template>

~~~
<%= caption "client/views/posts/post_submit.html" %>

Note: that’s a lot of markup, but it simply comes from using Twitter Bootstrap. 
While only the form elements are essential, 
the extra markup will help make our app look a little bit nicer. It should now look similar to this:
注意：かなりマークアップしましたが、　これはTwitter Bootstrapによるものです。
form要素だけは必要ですが、
残りのマークアップは　アプリの見た目を若干良くするために行っています。今はこのようになっているはずです。

<%= screenshot "7-1", "The post submit form" %>

This is a simple form. We don't need to worry about an action for it,
as we'll be intercepting submit events on the form and updating data via JavaScript. 
(It doesn't make sense to provide a non-JS fallback when you consider 
that a Meteor app is completely non-functional with JavaScript disabled).
これはシンプルなフォームです。私たちは　（action for it？）について心配する必要はありません。
これは（form？）で（submit events ？）を（intercepting？）して、JavaScriptでデータを更新するためです。
（？？？？？？？）

### Creating Posts

Let's bind an event handler to the form submit event.
It's best to use the submit event (rather than say a click event on the button),
as that will cover all possible ways of submitting (such as hitting enter in URL field for instance).
formのsubmit イベントに　イベントハンドラをバインドしていきましょう。
clickイベント（on the button？）よりもsubmitイベントを使うのがベストです。
それはsubmitイベントは　どのような投稿方法でもカバーするためです。
（たとえば、URLフィールドに（ hitting enter？）するようなものでも）

~~~js
Template.postSubmit.events({
  'submit form': function(e) {
    e.preventDefault();
    
    var post = {
      url: $(e.target).find('[name=url]').val(),
      title: $(e.target).find('[name=title]').val(),
      message: $(e.target).find('[name=message]').val()
    }
    
    post._id = Posts.insert(post);
    Router.go('postPage', post);
  }
});
~~~
<%= caption "client/views/posts/post_submit.js" %>

<%= commit "7-1", "Added a submit post page and linked to it in the header." %>

This function uses jQuery to parse out the values of our various form fields,
and populate a new post object from the results. 
We need to ensure we preventDefault on the event argument to our handler
to make sure the browser doesn't go ahead and try to submit the form.
この関数はさまざまな（form?）フィールドの値をはっきりさせるために　jQueryを使っています。　
また、その結果から新しい投稿オブジェクトを追加します（populate？）。
私たちは　ブラウザが　（doesn't go ahead and try to submit the form？）ための
イベントハンドラへの（event argument？）でpreventDefault　する必要があります。

Finally, we can route to our new post's page. 
The insert() function on a collection returns the generated id for the object that has been inserted into the database,
which the Router's go() function will use to construct a URL for us to browse to.
最終的に、私たちは新しい投稿ページにルーティングすることができました。
コレクションの　insert()関数 データベースに挿入されたオブジェクトに　生成されたidを返します。
（,which？）　ルーターの　go()関数は　　私たちがウェブで見るためのURLを構築します。（？？？）

The net result is the user hits submit, a post is created,
and the user is instantly taken to the discussion page for that new post.
その結果、　ユーザーは(submit？)にヒットして、投稿が作られて、
ユーザーは瞬時に　新しい投稿の　ディスカッションページ　に連れていきます。

### Adding Some Security

Creating posts is all very well, but we don't want to let any random visitor do it:
we want them to have to be logged in to do so. Of course, we can start by hiding the new post form from logged out users.
Still, a user could conceivably create a post in the browser console without being logged in, and we can't have that.
投稿を作るのは良いのですが、どんな人でも投稿を作れるようにしたくありません：
ユーザーがログインをした上で投稿を行うようにします。　もちろん、私たちはログアウトしたユーザーから　新しい投稿を見えなくするところから始めていきます。
もしかしたら、まだユーザーはブラウザーコンソールから　ログインすることなく　投稿を作ることができるかもしれません。　（and we can't have that？）　

Thankfully data security is baked right into Meteor collections;
it's just that it's turned off by default when you create a new project. 
This enables you to get started easily and start building out your app while leaving the boring stuff for later.
ありがたいことに、データセキュリティは　　Meteorコレクションに　（is baked right ？）
あなたが新しいプロジェクトを作るとき、（it？）は　初期設定では　止まっています。
（This？）で　簡単に　アプリを作り始める ことができるようになります。 退屈なことは後でやることになります。

Our app no longer needs these training wheels, so let's take them off! We'll remove the insecure package:
私たちが作ってきたアプリは　もうこうした補助輪が必要でなくなりましたので、補助輪をしていきましょう！insecureパッケージを削除します。

~~~bash
$ meteor remove insecure
~~~
<%= caption "Terminal" %>

After doing so, you'll notice that the post form no longer works. 
This is because without the insecure package, client-side inserts into the posts collection are no longer allowed.
We need to either give some explicit rules telling Meteor when it's OK for a client to insert posts, 
or else do our post insertions server-side.
そうした後で、　投稿フォームがもう（ works？）しないこと　　に気づくことでしょう。
これはinsecureパッケージがないと、クライアントサイドが（ allow？）されていない（ posts？）コレクションに挿入するからです。（？？？）（）
私たちは　Meteorに明確なルールを命令する必要があります。　クライアントが投稿を挿入して良いか　サーバーサイドで投稿を挿入するか
（？？？）

### Allowing Post Inserts

To begin with, we'll show how to allow client-side post inserts in order to get our form working again.
As it turns out, we'll eventually settle on a different technique, 
but for now, the following will get things working again easily enough:
フォームがまた　動くようにするために、私たちはクライアントの投稿の挿入を　許可するか示していきます。（？？？）
（As it turns out？）、私たちは　結局違った方法を　決めます。（？？？）
しかし今のところ、次のようにすることで　（ easily enough？）に　もう一度　動くようにでます。

~~~js
Posts = new Meteor.Collection('posts');

Posts.allow({
  insert: function(userId, doc) {
    // only allow posting if you are logged in
    return !! userId;
  }
});
~~~
<%= caption "collections/posts.js" %>
<%= highlight "3~8" %>

<%= commit "7-2", "Removed insecure, and allowed certain writes to posts." %>

We call Posts.allow, which tells Meteor
"this is a set of circumstances under which clients are allowed to do things to the Posts collection".
In this case, we are saying "clients are allowed to insert posts as long as they have a userId".
私たちPosts.allowを呼び出します。
Posts.allowは「これはクライアントが　Postsコレクションに　（do things？）しても良い状況だ。」と　Meteorに命令しています。（？？？）
この場合、私たちは「ユーザーが userIdを持つ人に限ってクライアントは投稿を挿入することを許可する」と言っています。

The userId of the user doing the modification is passed to the allow and deny calls
(or returns null if no user is logged in), which is almost always useful.
And as user accounts are tied into the core of Meteor, we can rely on userId always being correct.
ユーザーが　変更する　userIdは、　　 allowとdenyコールに引き渡されます。（？？？）
（ユーザーが誰もログインしていない場合はnullを返します。）これはほとんどの場合で役立ちます。
ユーザーアカウントは　Meteorの（core？）と結びついているので、　私たちは常に正しいuserIdであると確信が持てます。

We've managed to ensure that you need to be logged in to create a post.
Try logging out and creating a post; you should see this in your console:
私たちはなんとか　ユーザーが投稿を作るためにログインを必要とするように　できました。　

<%= screenshot "7-2", "Insert failed: Access denied " %>

However, we still have to deal with a couple of issues:
しかし、私たちはまだいくつかの問題に対処する必要があります。

Logged out users can still reach the create post form.
The post is not tied to the user in any way (and there's no code on the server to enforce this).
Multiple posts can be created that point to the same URL.
 - ログアウトしたユーザーは　まだ　（ the create post form？）に（ reach？）できます。
 - 投稿は（in any way？）　ユーザーに紐づけられていません。（またサーバーにこれを実行するためのコードがありません。）
 - 同じURLを（point to？）する（Multiple posts？）を作ることができます。　

Let's fix these problems.
では、こうした問題を修正していきましょう。

### Securing Access To The New Post Form

Let's start by preventing logged out users from seeing the post submit form.
We'll do that at the router level, by defining a route hook.
ログアウトしたユーザーが　（post submit form？）を見れなくするところから始めていきましょう。
私たちはルーターレベルでこれを行うために、ルートフックを定義します。

A hook intercepts the routing process and potentially changes the action that the router takes. 
You can think of it as a security guard that checks your credentials before letting you in (or turning you away).
フックは　ルーティングプロセスを（intercept？）して、（potentially？）に　ルーターが（take？）する行動を　変えます。
これはあなたが入る前にや出る時に　あなたの認証情報をチェックする　警備員　のようなものだと捉えることができます。　

What we need to do is check if the user is logged in,
and if they're not render the accessDenied template instead of the expected postSubmit template
(we then stop the router from doing anything else). So let's modify router.js like so:
私たちが必要なことは、　ユーザーがログインしているかどうかチェックして、　
（expected？）されたpostSubmitテンプレートの代わりに　accessDeniedテンプレートにレンダリングしないかをチェックします。（？？？）　
（この時、私たちは　ルーターが　何もしないようにします。）では、そのようにrouter.jsを修正していきましょう。

~~~js
Router.configure({
  layoutTemplate: 'layout'
});

Router.map(function() {
  this.route('postsList', {path: '/'});
  
  this.route('postPage', {
    path: '/posts/:_id',
    data: function() { return Posts.findOne(this.params._id); }
  });
  
  this.route('postSubmit', {
    path: '/submit'
  });
});

var requireLogin = function() {
  if (! Meteor.user()) {
    this.render('accessDenied');
    this.stop();
  }
}

Router.before(requireLogin, {only: 'postSubmit'});
~~~
<%= caption "lib/router.js" %>
<%= highlight "18~25" %>

We also create the template for the access denied page:
私たちは　アクセスが拒否されたページのための　テンプレートも作る必要があります。

~~~html
<template name="accessDenied">
  <div class="alert alert-error">You can't get here! Please log in.</div>
</template>
~~~
<%= caption "client/views/includes/access_denied.html" %>

<%= commit "7-3", "Denied access to new posts page when not logged in." %>

If you now head to http://localhost:3000/submit/ without being logged in, you should see this:
今　ログインせずにhttp://localhost:3000/submit/　に（head to ？）すると、このようになっています。

<%= screenshot "7-3", "The access denied template" %>

The nice thing about routing hooks is that they are reactive. 
This means we can be declarative and we don't need to think about callbacks, or similar, when the user logs in.
When the log-in state of the user changes, 
the Router's page template instantly changes from accessDenied to postSubmit 
without us having to write any explicit code to handle it.
ルーティングフックの素晴らしいところは、リアクティブなところです。
つまり、私たちは　宣言型に（ be？）できて、コールバックについて考える必要がないということです。ユーザーがログインする時も同様です。
ユーザーのログイン状態が変化するときに、私たちがそれを処理する明示的なコードを　書く必要がなく　
ルーターのページテンプレートは accessDeniedから　postSubmit に　瞬時に変化します。　

Log in, then try refreshing the page.
You might sometimes see the access denied template flash up for a brief moment
before the post submission page appears. 
The reason for this is that Meteor begins rendering templates
as soon as possible, before it has talked to the server
and checked if the user currently (stored in the browser's local storage) even exists.
ログインした時にページを再読み込みします。
拒否されたテンプレートが　（post submission？）ページが現れる前のほんのつかの間に　（flash up？）する
アクセスを見かけるかもしれません。　（？？？）
この理由は　サーバーと通信して、ブラウザーのローカルストレージに保存されユーザーが現在もいるのかチェックする前に
Meteorがすぐにテンプレートをレンダリングを始めるからです。（？？？）

To avoid this problem 
(which is a common class of problem that you'll see more of as you deal with the intricacies of latency 
between client and server), 
we'll just display a loading screen for the brief moment that we are waiting to see if the user has access or not.
この問題を回避するために、
（これはクライアントとサーバー間の（intricacies of latency ？）を処理する問題の共通（class？）です。）
私たちはユーザーがアクセスしているのかを見るために待つ短い間に　ロードするスクリーンを表示します。

After all at this stage we don't know if the user has the correct log-in credentials,
and we can't show either the accessDenied or the postSubmit template until we do.
結局、現在のところ私たちは　ユーザーが正しいログイン認証情報 の状態になっている　かどうかわかりません。
　私たちは　私たちが(do？)する限り　accessDenied　や postSubmitテンプレートを　表示することはできません。

So we modify our hook to use our loading template whilst Meteor.loggingIn() is true:
　私たちは　Meteor.loggingIn()がtrueの間はロードするテンプレートを使うために　フックを修正します。　
　
~~~js
Router.map(function() {
  this.route('postsList', {path: '/'});
  
  this.route('postPage', {
    path: '/posts/:_id',
    data: function() { return Posts.findOne(this.params._id); }
  });
  
  this.route('postSubmit', {
    path: '/submit'
  });
});

var requireLogin = function() {
  if (! Meteor.user()) {
    if (Meteor.loggingIn())
      this.render(this.loadingTemplate);
    else
      this.render('accessDenied');
    
    this.stop();
  }
}

Router.before(requireLogin, {only: 'postSubmit'});
~~~
<%= caption "lib/router.js" %>
<%= highlight "16~19" %>

<%= commit "7-4", "Show a loading screen while waiting to login." %>

### Hiding the Link

////

~~~html
<ul class="nav">
  {{#if currentUser}}<li><a href="{{pathFor 'postSubmit'}}">Submit Post</a></li>{{/if}}
</ul>
~~~
<%= caption "client/views/includes/header.html" %>

<%= commit "7-5", "Only show submit post link if logged in." %>

////

### Meteor Method: Better Abstraction and Security

////

- ////
- ////
- ////

////

- ////
- ////
- ////

////

////

////

~~~js
Template.postSubmit.events({
  'submit form': function(e) {
    e.preventDefault();
    
    var post = {
      url: $(e.target).find('[name=url]').val(),
      title: $(e.target).find('[name=title]').val(),
      message: $(e.target).find('[name=message]').val()
    }
    
    Meteor.call('post', post, function(error, id) {
      if (error)
        return alert(error.reason);
        
      Router.go('postPage', {_id: id});
    });
  }
});
~~~
<%= caption "client/views/posts/post_submit.js" %>

////

////

~~~js
Posts = new Meteor.Collection('posts');

Meteor.methods({
  post: function(postAttributes) {
    var user = Meteor.user(),
      postWithSameLink = Posts.findOne({url: postAttributes.url});
    
    // ensure the user is logged in
    if (!user)
      throw new Meteor.Error(401, "You need to login to post new stories");
    
    // ensure the post has a title
    if (!postAttributes.title)
      throw new Meteor.Error(422, 'Please fill in a headline');
    
    // check that there are no previous posts with the same link
    if (postAttributes.url && postWithSameLink) {
      throw new Meteor.Error(302, 
        'This link has already been posted', 
        postWithSameLink._id);
    }
    
    // pick out the whitelisted keys
    var post = _.extend(_.pick(postAttributes, 'url', 'title', 'message'), {
      userId: user._id, 
      author: user.username, 
      submitted: new Date().getTime()
    });
    
    var postId = Posts.insert(post);
    
    return postId;
  }
});
~~~
<%= caption "collections/posts.js" %>

<%= commit "7-6", "Use a method to submit the post." %>

////

////

////

////

////

////

////

### Sorting Posts

////

~~~js
Template.postsList.helpers({
  posts: function() {
    return Posts.find({}, {sort: {submitted: -1}});
  }
});
~~~
<%= caption "client/views/posts/posts_list.js" %>
<%= highlight "3" %>

<%= commit "7-7", "Sort posts by submitted timestamp." %>

////

////
