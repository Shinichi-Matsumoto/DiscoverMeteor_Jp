---
title: Creating Posts
slug: creating-posts
date: 0007/01/01
number: 7
contents: Learn how to submit a post client-side.|Implement a simple security check.|Restrict access to the post submit form.|Learn to use a server-side Method for added security.
paragraphs: 60
---

We've seen how easy it is to create posts via the console, 
using the Posts.insert database call,
but we can't expect our users to open the console to create a new post.
私たちはコンソール経由でデータベースを呼び出すPosts.insertを使うことで、いかに簡単に投稿を作るのか見てきました。
しかし私たちはユーザーがコンソールを開いて新しい投稿をすることを見込むことはできません。

Eventually, we'll need to build some kind of user interface to let our users post new stories to our app.
最終的に、私たちは　ユーザーがアプリに新しい（ stories？）を投稿できるように　ある種のユーザーインターフェースを作る必要があります。

### Building The New Post Page

We begin by defining a route for our new page:
新しいページにルートを定義する（？？？）ことから始めていきます。

~~~js
Router.configure({
  layoutTemplate: 'layout',
  loadingTemplate: 'loading',
  waitOn: function() { return Meteor.subscribe('posts'); }
});

Router.map(function() {
  this.route('postsList', {path: '/'});
  
  this.route('postPage', {
    path: '/posts/:_id',
    data: function() { return Posts.findOne(this.params._id); }
  });
  
  this.route('postSubmit', {
    path: '/submit'
  });
});
~~~
<%= caption "lib/router.js" %>
<%= highlight "13~15" %>

We're using the router's data function to set the postPage template's data context. 
Remember that whatever we put into the data context will be available as this inside the template helpers.
私たちはpostPageテンプレートのデータコンテキストを設定するために　ルーターのdata関数を使っています。
私たちがデータコンテキストに入れるものは　テンプレートヘルパー内で　使うことができることを覚えておきましょう。（？？？）　

### Adding A Link To The Header

With that route defined, we can now add a link to our submit page in our header:
ルートが定義されると、私たちは　ヘッダーにページを（submit？）するための　リンクを入れることができます。

~~~html
<template name="header">
  <header class="navbar">
    <div class="navbar-inner">
      <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </a>
      <a class="brand" href="{{pathFor 'postsList'}}">Microscope</a>
      <div class="nav-collapse collapse">
        <ul class="nav">
          <li><a href="{{pathFor 'postSubmit'}}">New</a></li>
        </ul>
        <ul class="nav pull-right">
          <li>{{loginButtons}}</li>
        </ul>
      </div>
    </div>
  </header>
</template>
~~~
<%= caption "client/views/includes/header.html" %>
<%= highlight "11~16" %>

Setting up our route means that if a user browses to the /submit URL,
Meteor will display the postSubmit template. So let's write that template:
ルートを設定するということは　ユーザーが　 /submit URLのウェブページを見るなら
Meteorが　postSubmitテンプレートを表示するということを意味しています。では、テンプレートを書いていきましょう。

~~~html
<template name="postSubmit">
  <form class="main">
    <div class="control-group">
        <label class="control-label" for="url">URL</label>
        <div class="controls">
            <input name="url" type="text" value="" placeholder="Your URL"/>
        </div>
    </div>

    <div class="control-group">
        <label class="control-label" for="title">Title</label>
        <div class="controls">
            <input name="title" type="text" value="" placeholder="Name your post"/>
        </div>
    </div>

    <div class="control-group">
        <label class="control-label" for="message">Message</label>
        <div class="controls">
            <textarea name="message" type="text" value=""/>
        </div>
    </div> 

    <div class="control-group">
        <div class="controls">
            <input type="submit" value="Submit" class="btn btn-primary"/>
        </div>
    </div>
  </form>
</template>

~~~
<%= caption "client/views/posts/post_submit.html" %>

Note: that’s a lot of markup, but it simply comes from using Twitter Bootstrap. 
While only the form elements are essential, 
the extra markup will help make our app look a little bit nicer. It should now look similar to this:
注意：かなりマークアップしましたが、　これはTwitter Bootstrapによるものです。
form要素だけは必要ですが、
残りのマークアップは　アプリの見た目を若干良くするために行っています。今はこのようになっているはずです。

<%= screenshot "7-1", "The post submit form" %>

This is a simple form. We don't need to worry about an action for it,
as we'll be intercepting submit events on the form and updating data via JavaScript. 
(It doesn't make sense to provide a non-JS fallback when you consider 
that a Meteor app is completely non-functional with JavaScript disabled).
これはシンプルなフォームです。私たちは　（action for it？）について心配する必要はありません。
これは（form？）で（submit events ？）を（intercepting？）して、JavaScriptでデータを更新するためです。
（？？？？？？？）

### Creating Posts

Let's bind an event handler to the form submit event.
It's best to use the submit event (rather than say a click event on the button),
as that will cover all possible ways of submitting (such as hitting enter in URL field for instance).
formのsubmit イベントに　イベントハンドラをバインドしていきましょう。
clickイベント（on the button？）よりもsubmitイベントを使うのがベストです。
それはsubmitイベントは　どのような投稿方法でもカバーするためです。
（たとえば、URLフィールドに（ hitting enter？）するようなものでも）

~~~js
Template.postSubmit.events({
  'submit form': function(e) {
    e.preventDefault();
    
    var post = {
      url: $(e.target).find('[name=url]').val(),
      title: $(e.target).find('[name=title]').val(),
      message: $(e.target).find('[name=message]').val()
    }
    
    post._id = Posts.insert(post);
    Router.go('postPage', post);
  }
});
~~~
<%= caption "client/views/posts/post_submit.js" %>

<%= commit "7-1", "Added a submit post page and linked to it in the header." %>

This function uses jQuery to parse out the values of our various form fields,
and populate a new post object from the results. 
We need to ensure we preventDefault on the event argument to our handler
to make sure the browser doesn't go ahead and try to submit the form.
この関数はさまざまな（form?）フィールドの値をはっきりさせるために　jQueryを使っています。　
また、その結果から新しい投稿オブジェクトを追加します（populate？）。
私たちは　ブラウザが　（doesn't go ahead and try to submit the form？）ための
イベントハンドラへの（event argument？）でpreventDefault　する必要があります。

Finally, we can route to our new post's page. 
The insert() function on a collection returns the generated id for the object that has been inserted into the database,
which the Router's go() function will use to construct a URL for us to browse to.
最終的に、私たちは新しい投稿ページにルーティングすることができました。
コレクションの　insert()関数 データベースに挿入されたオブジェクトに　生成されたidを返します。
（,which？）　ルーターの　go()関数は　　私たちがウェブで見るためのURLを構築します。（？？？）

The net result is the user hits submit, a post is created,
and the user is instantly taken to the discussion page for that new post.
その結果、　ユーザーは(submit？)にヒットして、投稿が作られて、
ユーザーは瞬時に　新しい投稿の　ディスカッションページ　に連れていきます。

### Adding Some Security

Creating posts is all very well, but we don't want to let any random visitor do it:
we want them to have to be logged in to do so. Of course, we can start by hiding the new post form from logged out users.
Still, a user could conceivably create a post in the browser console without being logged in, and we can't have that.
投稿を作るのは良いのですが、どんな人でも投稿を作れるようにしたくありません：
ユーザーがログインをした上で投稿を行うようにします。　もちろん、私たちはログアウトしたユーザーから　新しい投稿を見えなくするところから始めていきます。
もしかしたら、まだユーザーはブラウザーコンソールから　ログインすることなく　投稿を作ることができるかもしれません。　（and we can't have that？）　

Thankfully data security is baked right into Meteor collections;
it's just that it's turned off by default when you create a new project. 
This enables you to get started easily and start building out your app while leaving the boring stuff for later.
ありがたいことに、データセキュリティは　　Meteorコレクションに　（is baked right ？）
あなたが新しいプロジェクトを作るとき、（it？）は　初期設定では　止まっています。
（This？）で　簡単に　アプリを作り始める ことができるようになります。 退屈なことは後でやることになります。

Our app no longer needs these training wheels, so let's take them off! We'll remove the insecure package:
私たちが作ってきたアプリは　もうこうした補助輪が必要でなくなりましたので、補助輪をしていきましょう！insecureパッケージを削除します。

~~~bash
$ meteor remove insecure
~~~
<%= caption "Terminal" %>

After doing so, you'll notice that the post form no longer works. 
This is because without the insecure package, client-side inserts into the posts collection are no longer allowed.
We need to either give some explicit rules telling Meteor when it's OK for a client to insert posts, 
or else do our post insertions server-side.
そうした後で、　投稿フォームがもう（ works？）しないこと　　に気づくことでしょう。
これはinsecureパッケージがないと、クライアントサイドが（ allow？）されていない（ posts？）コレクションに挿入するからです。（？？？）（）
私たちは　Meteorに明確なルールを命令する必要があります。　クライアントが投稿を挿入して良いか　サーバーサイドで投稿を挿入するか
（？？？）

### Allowing Post Inserts

To begin with, we'll show how to allow client-side post inserts in order to get our form working again.
As it turns out, we'll eventually settle on a different technique, 
but for now, the following will get things working again easily enough:
フォームがまた　動くようにするために、私たちはクライアントの投稿の挿入を　許可するか示していきます。（？？？）
（As it turns out？）、私たちは　結局違った方法を　決めます。（？？？）
しかし今のところ、次のようにすることで　（ easily enough？）に　もう一度　動くようにでます。

~~~js
Posts = new Meteor.Collection('posts');

Posts.allow({
  insert: function(userId, doc) {
    // only allow posting if you are logged in
    return !! userId;
  }
});
~~~
<%= caption "collections/posts.js" %>
<%= highlight "3~8" %>

<%= commit "7-2", "Removed insecure, and allowed certain writes to posts." %>

We call Posts.allow, which tells Meteor
"this is a set of circumstances under which clients are allowed to do things to the Posts collection".
In this case, we are saying "clients are allowed to insert posts as long as they have a userId".
私たちPosts.allowを呼び出します。
Posts.allowは「これはクライアントが　Postsコレクションに　（do things？）しても良い状況だ。」と　Meteorに命令しています。（？？？）
この場合、私たちは「ユーザーが userIdを持つ人に限ってクライアントは投稿を挿入することを許可する」と言っています。

The userId of the user doing the modification is passed to the allow and deny calls
(or returns null if no user is logged in), which is almost always useful.
And as user accounts are tied into the core of Meteor, we can rely on userId always being correct.
ユーザーが　変更する　userIdは、　　 allowとdenyコールに引き渡されます。（？？？）
（ユーザーが誰もログインしていない場合はnullを返します。）これはほとんどの場合で役立ちます。
ユーザーアカウントは　Meteorの（core？）と結びついているので、　私たちは常に正しいuserIdであると確信が持てます。

We've managed to ensure that you need to be logged in to create a post.
Try logging out and creating a post; you should see this in your console:
私たちはなんとか　ユーザーが投稿を作るためにログインを必要とするように　できました。　

<%= screenshot "7-2", "Insert failed: Access denied " %>

However, we still have to deal with a couple of issues:
しかし、私たちはまだいくつかの問題に対処する必要があります。

Logged out users can still reach the create post form.
The post is not tied to the user in any way (and there's no code on the server to enforce this).
Multiple posts can be created that point to the same URL.
 - ログアウトしたユーザーは　まだ　（ the create post form？）に（ reach？）できます。
 - 投稿は（in any way？）　ユーザーに紐づけられていません。（またサーバーにこれを実行するためのコードがありません。）
 - 同じURLを（point to？）する（Multiple posts？）を作ることができます。　

Let's fix these problems.
では、こうした問題を修正していきましょう。

### Securing Access To The New Post Form

Let's start by preventing logged out users from seeing the post submit form.
We'll do that at the router level, by defining a route hook.
ログアウトしたユーザーが　（post submit form？）を見れなくするところから始めていきましょう。
私たちはルーターレベルでこれを行うために、ルートフックを定義します。

A hook intercepts the routing process and potentially changes the action that the router takes. 
You can think of it as a security guard that checks your credentials before letting you in (or turning you away).
フックは　ルーティングプロセスを（intercept？）して、（potentially？）に　ルーターが（take？）する行動を　変えます。
これはあなたが入る前にや出る時に　あなたの認証情報をチェックする　警備員　のようなものだと捉えることができます。　

What we need to do is check if the user is logged in,
and if they're not render the accessDenied template instead of the expected postSubmit template
(we then stop the router from doing anything else). So let's modify router.js like so:
私たちが必要なことは、　ユーザーがログインしているかどうかチェックして、　
（expected？）されたpostSubmitテンプレートの代わりに　accessDeniedテンプレートにレンダリングしないかをチェックします。（？？？）　
（この時、私たちは　ルーターが　何もしないようにします。）では、そのようにrouter.jsを修正していきましょう。

~~~js
Router.configure({
  layoutTemplate: 'layout'
});

Router.map(function() {
  this.route('postsList', {path: '/'});
  
  this.route('postPage', {
    path: '/posts/:_id',
    data: function() { return Posts.findOne(this.params._id); }
  });
  
  this.route('postSubmit', {
    path: '/submit'
  });
});

var requireLogin = function() {
  if (! Meteor.user()) {
    this.render('accessDenied');
    this.stop();
  }
}

Router.before(requireLogin, {only: 'postSubmit'});
~~~
<%= caption "lib/router.js" %>
<%= highlight "18~25" %>

We also create the template for the access denied page:
私たちは　アクセスが拒否されたページのための　テンプレートも作る必要があります。

~~~html
<template name="accessDenied">
  <div class="alert alert-error">You can't get here! Please log in.</div>
</template>
~~~
<%= caption "client/views/includes/access_denied.html" %>

<%= commit "7-3", "Denied access to new posts page when not logged in." %>

If you now head to http://localhost:3000/submit/ without being logged in, you should see this:
今　ログインせずにhttp://localhost:3000/submit/　に（head to ？）すると、このようになっています。

<%= screenshot "7-3", "The access denied template" %>

The nice thing about routing hooks is that they are reactive. 
This means we can be declarative and we don't need to think about callbacks, or similar, when the user logs in.
When the log-in state of the user changes, 
the Router's page template instantly changes from accessDenied to postSubmit 
without us having to write any explicit code to handle it.
ルーティングフックの素晴らしいところは、リアクティブなところです。
つまり、私たちは　宣言型に（ be？）できて、コールバックについて考える必要がないということです。ユーザーがログインする時も同様です。
ユーザーのログイン状態が変化するときに、私たちがそれを処理する明示的なコードを　書く必要がなく　
ルーターのページテンプレートは accessDeniedから　postSubmit に　瞬時に変化します。　

Log in, then try refreshing the page.
You might sometimes see the access denied template flash up for a brief moment
before the post submission page appears. 
The reason for this is that Meteor begins rendering templates
as soon as possible, before it has talked to the server
and checked if the user currently (stored in the browser's local storage) even exists.
ログインした時にページを再読み込みします。
拒否されたテンプレートが　（post submission？）ページが現れる前のほんのつかの間に　（flash up？）する
アクセスを見かけるかもしれません。　（？？？）
この理由は　サーバーと通信して、ブラウザーのローカルストレージに保存されユーザーが現在もいるのかチェックする前に
Meteorがすぐにテンプレートをレンダリングを始めるからです。（？？？）

To avoid this problem 
(which is a common class of problem that you'll see more of as you deal with the intricacies of latency 
between client and server), 
we'll just display a loading screen for the brief moment that we are waiting to see if the user has access or not.
この問題を回避するために、
（これはクライアントとサーバー間の（intricacies of latency ？）を処理する問題の共通（class？）です。）
私たちはユーザーがアクセスしているのかを見るために待つ短い間に　ロードするスクリーンを表示します。

After all at this stage we don't know if the user has the correct log-in credentials,
and we can't show either the accessDenied or the postSubmit template until we do.
結局、現在のところ私たちは　ユーザーが正しいログイン認証情報 の状態になっている　かどうかわかりません。
　私たちは　私たちが(do？)する限り　accessDenied　や postSubmitテンプレートを　表示することはできません。

So we modify our hook to use our loading template whilst Meteor.loggingIn() is true:
　私たちは　Meteor.loggingIn()がtrueの間はロードするテンプレートを使うために　フックを修正します。　
　
~~~js
Router.map(function() {
  this.route('postsList', {path: '/'});
  
  this.route('postPage', {
    path: '/posts/:_id',
    data: function() { return Posts.findOne(this.params._id); }
  });
  
  this.route('postSubmit', {
    path: '/submit'
  });
});

var requireLogin = function() {
  if (! Meteor.user()) {
    if (Meteor.loggingIn())
      this.render(this.loadingTemplate);
    else
      this.render('accessDenied');
    
    this.stop();
  }
}

Router.before(requireLogin, {only: 'postSubmit'});
~~~
<%= caption "lib/router.js" %>
<%= highlight "16~19" %>

<%= commit "7-4", "Show a loading screen while waiting to login." %>

### Hiding the Link

The easiest way to prevent users from trying to reach this page by mistake 
when they are logged out is to hide the link from them.
We can do this pretty easily:
ユーザーがログアウトしたした時に誤ってこのページに（reach ？）しないようにする最も簡単な方法は、
リンクを非表示にすることです。
このようにするには簡単にすることができます。（？？？）


~~~html
<ul class="nav">
  {{#if currentUser}}<li><a href="{{pathFor 'postSubmit'}}">Submit Post</a></li>{{/if}}
</ul>
~~~
<%= caption "client/views/includes/header.html" %>

<%= commit "7-5", "Only show submit post link if logged in." %>

The currentUser helper is provided to us by the accounts package and is the Spacebars equivalent of Meteor.user(). 
Since it's reactive, the link will appear or disappear as you log in and out of the app.
currentUserヘルパーは　アカウントパッケージで（provide？）されていて、　Meteor.user()の　Spacebarsの（ equivalent？）です。
(it?)はリアクティブなので、リンクは（ appear or disappear ？）です。（？？？）

### Meteor Method: Better Abstraction and Security

We've managed to secure access to the new post page for logged out users, 
and deny such users from creating posts even if they cheat and use the console.
Yet there are still a few more things we need to take care of:
私たちは　ログアウトしたユーザーのために　新しい投稿ページへのアクセスを（secure ？）にしたので、
たとえユーザーがずるをしてコンソールを使うとしても　投稿を作れないようにします。
まだ、対処するすべきことがいくつかあります。

Timestamping the posts.
Ensuring that the same URL can't be posted more than once.
Adding details about the post author (ID, username, etc.).
- 投稿へのタイムスタンプを（？？？）
- 同じURLが投稿できないようにする
- 投稿作成者についての詳細(ID, usernameなど)を付け足す。

You may be thinking we can do all of that in our submit event handler. 
Realistically, however, we would quickly run into a range of problems.
こうしたことは（submit？）したイベントハンドラでできると考えることができます。
しかし、現実的には　すぐに　幅広い問題に　（run into？）します。

For the timestamp, we'd have to rely on the user's computer's time being correct, 
which is not always going to be the case.

Clients won't know about all of the URLs ever posted to the site. 
They'll only know about the posts that they can currently see (we'll see how exactly this works later), 
so there's no way to enforce URL uniqueness client-side.

Finally, although we could add the user details client-side, we wouldn't be enforcing its accuracy, 
which could open our app up to exploitation by people using the browser console.

- タイムスタンプでは、私たちは　ユーザーのコンピュータの時間が正しいとみなす必要があります。
　（which is not always going to be the case.？）　
- クライアントは今まで　サイトに投稿されたすべてのURL　について知りません。
　クライアントは　現在見ている投稿　についてだけ知っています。（これがいかに正確なのかは後々見ていきます）
　そのため、　URL　（uniqueness？）　クライアントサイドを（enforce？）することはできません。
- 最後に　私たちは　クライアントサイドに　ユーザーの詳細を追加しましたが、
　私たちは正確にそれを　（enforce?）できないので、
　ブラウザーコンソールを使うことで、（ up to exploitation？）、アプリを開くことができます。

For all these reasons, it's better to keep our event handlers simple and,
if we are doing more than the most basic inserts or updates to collections, use a Method.
以上のような理由から、イベントハンドラをシンプルに保つことが良いということになります。
もし　最も基本的な　コレクションへの挿入や更新以上のことをするとしたら、メソッドを使います。

A Meteor Method is a server-side function that is called client-side. 
We aren't totally unfamiliar with them -- in fact, behind the scenes,
the Collection's insert, update and remove functions are all Methods. Let's see how to create our own.
Meteor のメソッドは　クライアントサイドで（ is call？）される　サーバーサイドの関数です。
私たちはこのことについてよく慣れ親しでいますす。
（？？？）、裏側でCollectionの insertや update、 remove関数はすべてメソッドです。
どのように（our own？）を　作るのか　見ていきましょう。

Let's go back to post_submit.js.
Rather than inserting directly into the Posts collection, we'll call a Method named post:
まず、post_submit.jsに戻りましょう。
Postsコレクションに直接挿入するよりも、 postというメソッドを呼び出しましょう。

~~~js
Template.postSubmit.events({
  'submit form': function(e) {
    e.preventDefault();
    
    var post = {
      url: $(e.target).find('[name=url]').val(),
      title: $(e.target).find('[name=title]').val(),
      message: $(e.target).find('[name=message]').val()
    }
    
    Meteor.call('post', post, function(error, id) {
      if (error)
        return alert(error.reason);
        
      Router.go('postPage', {_id: id});
    });
  }
});
~~~
<%= caption "client/views/posts/post_submit.js" %>

The Meteor.call function calls a Method named by its first argument.
You can provide arguments to the call (in this case, the post object we constructed from the form), 
and finally attach a callback, which will execute when the server-side Method is done.
Here we simply alert the user if there's a problem,
or redirect the user to the freshly created post's discussion page if not.
Meteor.call関数は　（ by its first argument？＝第一引数によって？）指定したメソッドを呼び出します。
　（ the call ？）に引数を与えることができます。（この場合は、（ form？）から作られたpostオブジェクト）
最後に、サーバーサイドのメソッドが行われた時に実行する　コールバックを（attach？）します。　
ここで私たちは　　問題があった場合にユーザーに警告を出します。
もし問題がない場合は　ユーザーを　最新の投稿ディスカッションページにリダイレクトします。

We then define the Method in our collections/posts.js file.
We'll remove the allow() block from posts.js since Meteor Methods bypass them anyway.
Remember that Methods are executed on the server, so Meteor assumes they can be trusted.
それから、私たちはcollections/posts.jsファイルでメソッドを定義します。
とにかく、Meteorメソッドは（bypass them？）するので、　私たちはposts.jsからallow()ブロックを削除します。
メソッドはサーバーで実行されるため、Meteorは（they ？）が信頼に値すると見なします。

~~~js
Posts = new Meteor.Collection('posts');

Meteor.methods({
  post: function(postAttributes) {
    var user = Meteor.user(),
      postWithSameLink = Posts.findOne({url: postAttributes.url});
    
    // ensure the user is logged in
    if (!user)
      throw new Meteor.Error(401, "You need to login to post new stories");
    
    // ensure the post has a title
    if (!postAttributes.title)
      throw new Meteor.Error(422, 'Please fill in a headline');
    
    // check that there are no previous posts with the same link
    if (postAttributes.url && postWithSameLink) {
      throw new Meteor.Error(302, 
        'This link has already been posted', 
        postWithSameLink._id);
    }
    
    // pick out the whitelisted keys
    var post = _.extend(_.pick(postAttributes, 'url', 'title', 'message'), {
      userId: user._id, 
      author: user.username, 
      submitted: new Date().getTime()
    });
    
    var postId = Posts.insert(post);
    
    return postId;
  }
});
~~~
<%= caption "collections/posts.js" %>

<%= commit "7-6", "Use a method to submit the post." %>

This Method is a little complicated, but hopefully you can follow along.
このメソッドは少し複雑になっていますが、なんとか話についていくことができるでしょう。

First, we define our user variable and check if a post with the same link already exists. 
Then, we check to see that the user is logged in, throwing an error 
(which will eventually be alert-ed by the browser) if not.
We also do some simple validation of the post object to make sure that our posts have titles.
最初に、私たちはuser変数を定義して、同じリンクがすでに存在しているかどうかチェックします。
それから、　ユーザーがログインしているかチェックして、ログインしてない場合はエラーを（throw？）します。
（最終的にブラウザーでalertされます。）
私たちは　投稿にタイトルがあるか確認する（the post？）オブジェクトの妥当性を検証します。　

Next, if there's another post with the same URL, we throw a 302 error
(which means redirect) telling the user that they should just go and look at that previously created post.
次に、同じURLの投稿があった場合に、302 errorを（throw？）します。（これはリダイレクトするという意味です。）
ユーザーに　以前作られた投稿に（should just go and look？）するように伝えます。

Meteor's Error class takes three arguments. 
The first one (error) is an error code of your choice (in this case we're picking 302),
the second one (reason) is a short human-readable explanation of the error,
and the last one (details) can be any useful additional information.
MeteorのErrorクラスは３つの引数をとります。
１つめのerrorは選択したエラーコードです。（この場合では302）
２つめのreasonは人間が読み取れるエラーの説明です。
３つめのdetailsは、　役立つ追加情報となります。

In our case, we'll use this third argument to pass the ID of the post that we just found.
Spoiler alert: we'll use this later on to redirect the user to the pre-existing post.
この場合、私たちは　見つけた投稿のIDを渡すために　３つの引数を使います。
ネタバレ注意：以前から存在している投稿にユーザーをリダイレクトするために、私たちは後でこれを使います。　

If all those checks pass, we grab the fields that we want to insert 
(to ensure a user calling this Method in browser console can't put spurious data into our database), 
and include some information about the submitting user -- as well as the current time -- into the post.
すべてのチェックが終わると、私たちは　　挿入したいフィールドを(grab?)します。
（　ユーザーがブラウザーコンソールでこのメソッドを呼び出す（ensure？）　は（spurious？）データをデータベースに入れることができません。　）
投稿に（submit？）ユーザーについての情報と現在の時間を（include ？）します。

Finally, we insert the post, and return the new post's id to the user.
最後に、私たちは投稿を挿入して、ユーザーに新しい投稿のidを返します。

### Sorting Posts

Now that we have a submitted date on all our posts, 
it makes sense to ensure that they are sorted using this attribute.
To do so, we can just use Mongo's sort operator, which expects an object consisting of the keys to sort by,
and a sign indicating whether they are ascending or descending.
これで私たちは　すべての投稿に（submitted？）した日時があるので、
　この属性を使うことで（？？？？？？）。
そうするために、私たちはソートするためのキーを構成するオブジェクトを（expect？）するMongoDBの sort演算子を使うことができます。　
（and a sign indicating whether they are ascending or descending？？？）

~~~js
Template.postsList.helpers({
  posts: function() {
    return Posts.find({}, {sort: {submitted: -1}});
  }
});
~~~
<%= caption "client/views/posts/posts_list.js" %>
<%= highlight "3" %>

<%= commit "7-7", "Sort posts by submitted timestamp." %>

It took a bit of work, but we finally have a user interface to let users securely enter content in our app!
ちょっとした労力がいりましたが、私たちは最終的に　アプリ内でユーザーが安全に内容を入力できるユーザーインターフェースを（have？）　　　

But any app that lets users create content also needs to give them a way to edit or delete it.
That's what the Editing Posts chapter will be all about.
しかし　ユーザーが　内容を作ることができるすべてのアプリは　編集したり削除する方法を（ give？）する必要があります。
この点は　 Editing Postsの章で学ぶことになります。
