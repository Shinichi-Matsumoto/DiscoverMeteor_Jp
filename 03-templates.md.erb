---
title: Templates
slug: templates
date: 0003/01/01
number: 3
contents: Learn about Meteor's templating language, Handlebars.|Create your first three templates.|Learn how Meteor managers work.|Get a basic prototype working with static data.
paragraphs: 46
---

Meteorでの開発を簡単にするため、私たちはアウトサイドインアプローチをとることになります。
つまり、私たちは最初に　「」　HTMLとJavaScriptで外側の骨組みを作り、それからアプリが内側で動くように繋いでいきます。

この章では、 /clientディレクトリの内側で何が起きているのか　気にかけるだけとなります。

/clientディレクトリの中に main.htmlという新しいファイルを作りましょう。
そして次のようなコードを書き込みましょう。

~~~html
<head>
  <title>Microscope</title>
</head>
<body>
  <div class="container">
    <header class="navbar">
      <div class="navbar-inner">
        <a class="brand" href="/">Microscope</a>
      </div>
    </header>
    <div id="main" class="row-fluid">
      {{> postsList}}
    </div>
  </div>
</body>
~~~
<%= caption "client/main.html" %>

これがアプリのメインテンプレートとなります。
ご覧のように、{{> postsList}}タグ以外は全てHTMLです。
{{> postsList}}タグはpostsListテンプレートの挿入場所となります。
では、テンプレートを作っていきましょう。

### Meteorテンプレート

ソーシャルニュースサイトは一覧表となった投稿によって作られています。
そうなるようにテンプレートを作っていきす。

 /clientの中に/viewsディレクトリを作りましょう。
 /viewsディレクトリの中に全てのテンプレートを置くことになります。
 /viewsの中を整理するため、投稿に関連したテンプレートはviews内に/postsを作ります。
 

<% note do %>

### ファイルを見つける

Meteorはファイルを見つけることに優れています。
/clientディレクトリにコードを入れれば、Meteorはそれを見つけて正確にコンパイルしてくれます。
つまり、JavaScriptやCSSへのインクルードパスを手動で書く必要がなくなるということです。

それはまた、同じディレクトリに全てのファイルを置くことができるということでもあります。
さらには、同じファイルに全てのコードを置くこともできます。
Meteorは全てを１つのファイルにコンパイルしてしまうため、ファイル内はきちんと整理してきれいなファイル構造にした方が良いでしょう。

<% end %>

これから２つのテンプレートを作っていきます。
client/views/postsの中にposts_list.htmlを作ります。

~~~html
<template name="postsList">
  <div class="posts">
    {{#each posts}}
      {{> postItem}}
    {{/each}}
  </div>
</template>
~~~
<%= caption "client/views/posts/posts_list.html" %>

次にpost_item.htmlを作ります。

~~~html
<template name="postItem">
  <div class="post">
    <div class="post-content">
      <h3><a href="{{url}}">{{title}}</a><span>{{domain}}</span></h3>
    </div>
  </div>
</template>
~~~
<%= caption "client/views/posts/post_item.html" %>

テンプレート要素の name="postsList"属性を書き込みます。

テンプレートがどこに行くのか　（？？？）

ここでMeteorのテンプレートシステム、Spacebarsについて紹介します。
SpacebarsではHTMLにpartialsとexpressionsとblock helpersの３つを付け加えます。

Partialsでは{{> templateName}}構文を使い、partialを同じ名前のテンプレートに置き換えるようMeteorに命令します。
（ここではpostItem）←（？？？）

{{title}}のようなExpressionsは、オブジェクトのプロパティを呼び出すか、テンプレートマージャーで定義されているtemplate helperの値を返します。
（そのことについては後で述べます。）

最後に、block helpersは{{#each}}…{{/each}} や {{#if}}…{{/if}}のようなテンプレートを制御する特別なタグです。

<% note do %>

### Going Further

もしSpacebarsについてさらに学びたいという場合は、 Spacebars documentationを参照することができます。

<% end %>

この知識があると、ここでどんなことが起こっているのか簡単に理解することができます。

最初にpostsListテンプレートの中で、{{#each}}…{{/each}} block helperを使ってpostsオブジェクトに繰り返し処理を行っています。

postsオブジェクトがどこからやって来たのでしょうか？
それは実際のところ、テンプレートヘルパーから

////

////

### Template Managers

ここまでSpacebarsについて取り組んできました。
Spacebarsはいくつかのタグを散りばめたHTMLです。
PHPのような他の言語と違い、Meteorがテンプレートと他のロジックを分離した状態にします。
テンプレートそれ自体が分離させるわけではありません。

（？？？）　ためには、テンプレートにマネージャーが必要です。
　このマネージャーは　生の食材（データ）をとってきて準備をするシェフのようなものと見なすことができます。
（？？？）

言い換えれば、テンプレートの役割は表示をすることと変数をループすることに限定されます。
マネージャーが　値を変数に割り当て　（？？？）

<% note do %>

### Managers?

私たちがMeteor開発者たちにテンプレートマネージャーを何と呼んでいるのか聞いて回ったところ、
半分の人が「コントローラー」だと言い、もう半分の人は「JavaScriptのコードを置くファイル」だと言いました。

実際のところ、マネージャーはコントローラーではありません。
少なくともMVCでの意味のコントローラーではありません。
「JavaScriptのコードを置くファイル」と呼ぶのも受けが良さそうではありません。
そのため、どちらの意見も却下しました。

私たちは何と呼べばよいのかを決めたかったため、「マネージャー」という言葉を考えだしました。
webフレームワークに関係したことでマネージャーという言葉は（？？？）　以前から存在する意味ではありませんでした。

<% end %>

  .js拡張子　（？？？）
  では早速　/client/views/postsの中にposts_list.jsを作って、最初のマネージャーを作っていきましょう。

~~~js
var postsData = [
  {
    title: 'Introducing Telescope',
    author: 'Sacha Greif',
    url: 'http://sachagreif.com/introducing-telescope/'
  }, 
  {
    title: 'Meteor',
    author: 'Tom Coleman',
    url: 'http://meteor.com'
  }, 
  {
    title: 'The Meteor Book',
    author: 'Tom Coleman',
    url: 'http://themeteorbook.com'
  }
];
Template.postsList.helpers({
  posts: postsData
});
~~~
<%= caption "client/views/posts/posts_list.js" %>

正しくできたなら、ブラウザでは次のように表示されているでしょう。

<%= screenshot "3-1", "Our first templates with static data" %>

<%= commit "3-1", "Added basic posts list template and static data." %>

私たちはここで２つのことをしています。
まず１つ目に　postsData配列の中にダミープロトタイプデータを構成しています。
通常、データはデータベースからやって来ます。
この点は次の章で学びますので、静的データを使って「ごまかして」います。

２つ目に postsをテンプレートヘルパーに定義するため、Meteorの Template.myTemplate.helpers()関数を使っています。
postsは、postsData配列を返します。

postsヘルパーを定義するということは、テンプレートでも使うことができるということです。

~~~html
<template name="postsList">
  <div class="posts">
    {{#each posts}}
      {{> postItem}}
    {{/each}}
  </div>
</template>
~~~
<%= caption "client/views/posts/posts_list.html" %>

そのため、このテンプレートではpostsData配列を繰り返し処理ができる　　postItemテンプレート内で　（？？？）

### "this"の値

私たちは今post_item.jsマネージャーを作りました。

~~~js
Template.postItem.helpers({
  domain: function() {
    var a = document.createElement('a');
    a.href = this.url;
    return a.hostname;
  }
});
~~~
<%= caption "client/views/posts/post_item.js" %>

<%= commit "3-2", "Setup a `domain` helper on the `postItem`." %>

今回のdomainヘルパーの値は配列ではなく、無名関数です。
このパターンは先ほどのダミーデータの例と比べて、より一般的で役立ちます。


<%= screenshot "3-2", "それぞれのリンクにドメインを表示する" %>

domainヘルパーはURLを取ってきて、ちょっとしたJavaScriptのマジックによってドメインを返します。
ですが、そもそもURLはどこから取ってきたのでしょうか？

この疑問に答えるには、 posts_list.htmlテンプレートまで戻る必要があります。
{{#each}}ブロックヘルパーは配列を繰り返し処理するだけではありません。
ブロックの中のthisの値を繰り返し処理されたオブジェクトに設定するのです。

////（？？？）

ここまでで、なぜthis.urlがpostのURLを返すのか理解できるでしょう。
また、post_item.html テンプレートの中の{{title}} と {{url}}を使う場合、　
Meteorはそれがthis.titleとthis.urlであることを認識し、正しい値を返します。

<% note do %>

### JavaScriptマジック

Meteorに限ったことではないのですが、ここで先ほどの「JavaScriptマジック」について解説しましょう。
まず、HTMLで空のアンカー要素(a)を作り、メモリに記憶します。

その時に　 postのURLと等しくなるようにhref属性を設定しています。
（このように、ヘルパーにおいて　this　は現在動作しているオブジェクトのことです。）・・・（？？？）

最後に、　　残りのURLがなくてもリンクのドメイン名を返すので、a要素のhostnameプロパティを使用しています。

<% end %>

ここまで理解ができたら、ブラウザでpostのリストを見ることができるでしょう。
そのリストは単なる静的データです。
そのため、まだMeteorのリアルタイムに関する特徴ついて使っていません。
次の章ではその点について見て行きましょう！

<% note do %>

### Hot Code Reload　・・（？？？）

ファイルを変えた際に手動でブラウザをリロードをする必要がないことにお気づきでしょうか。


これはMeteorがプロジェクトディレクトリ内で全てのファイルを読み込み、変更点を見つけると自動的にブラウザを更新するためです。

Meteorのホットコードリロードはとてもスマートであり、  アプリの状態を保存する　（？？？）

<% end %>
