---
title: Templates
slug: templates
date: 0003/01/01
number: 3
contents: Learn about Meteor's templating language, Handlebars.|Create your first three templates.|Learn how Meteor managers work.|Get a basic prototype working with static data.
paragraphs: 46
---

To ease into Meteor development, we'll adopt an outside-in approach. 
In other words we'll build a "dumb" HTML/JavaScript outer shell first, 
and then hook it up to our app's inner workings later on.
　Meteorでの開発を簡単にするため、私たちはアウトサイドインアプローチを用いることになります。
　要するに、私たちは最初に（"dumb"？）なHTMLとJavaScriptで外側の骨組みを作り、
　それから後でアプリが内側で動くように繋いでいきます。

This means that in this chapter we'll only concern ourselves with what's happening inside the /client directory.
　つまり、この章では /clientディレクトリの内側で何が起きるのか懸念するだけとなります。

Let's create a new file named main.html inside our /client directory, and fill it with the following code:
　では、/clientディレクトリの中に main.htmlという新しいファイルを作って、次のようなコードを書き込みましょう：

~~~html
<head>
  <title>Microscope</title>
</head>
<body>
  <div class="container">
    <header class="navbar">
      <div class="navbar-inner">
        <a class="brand" href="/">Microscope</a>
      </div>
    </header>
    <div id="main" class="row-fluid">
      {{> postsList}}
    </div>
  </div>
</body>
~~~
<%= caption "client/main.html" %>

This will be our main app template. 
As you can see it's all HTML except for a single {{> postsList}} tag, 
which is an insertion point for the postsList template as we'll soon see. 
For now, let's create a couple more templates.
　これは（main app template？）となります。
　ご覧のように、{{> postsList}}タグ以外はすべてHTMLです。
　{{> postsList}}タグは、これから見ていくpostsListテンプレートの挿入場所となります。
　では、いくつかテンプレートを作っていきましょう。

### Meteorテンプレート

At its core, a social news site is composed of posts organized in lists,
and that's exactly how we'll organize our templates.
　根本的には、ソーシャルニュースサイトは一覧表となった投稿によって構成されています。
　私たちはまさにそうなるようにテンプレートを作っていきす。

Let's create a /views directory inside /client. 
This will be where we put all our templates, 
and to keep things tidy we'll also create /posts inside /views just for our post-related templates.
　では、/clientの中に/viewsディレクトリを作りましょう。
　私たちは/viewsディレクトリの中にすべてのテンプレートを置くことになります。
　/viewsディレクトリ内を整理したいので、投稿に関連したテンプレートのために、/views内に/postsを作ります。（？？？）
 

<% note do %>

### ファイルを見つける

Meteor is great at finding files.
No matter where you put your code in the /client directory, Meteor will find it and compile it properly.
This means you never need to manually write include paths for JavaScript or CSS files.
　Meteorはファイルを見つけることが得意です。
　/clientディレクトリ内のどこにコードを入れようと、Meteorはコードを見つけてきて正確にコンパイルします。
　つまり、JavaScriptやCSSへのインクルードパスを手で書く必要がありません。

It also means you could very well put all your files in the same directory, 
or even all your code in the same file.
But since Meteor will compile everything to a single minified file anyway,
we'd rather keep things well-organized and use a cleaner file structure.
　また、同じディレクトリにすべてのファイルを置くことができるということでもあります。
　さらには、同じファイルにすべてのコードを置くこともできます。
　しかし、Meteorはすべてのコードを小さくした１つのファイルにコンパイルしてしまうので、
　ファイル内をきちんと整理して、きれいなファイル構造にすると良いでしょう。

<% end %>

We're finally ready to create our second template.
Inside client/views/posts, create posts_list.html:
　これから２つのテンプレートを作っていきます。
　client/views/postsの中にposts_list.htmlを作ります。

~~~html
<template name="postsList">
  <div class="posts">
    {{#each posts}}
      {{> postItem}}
    {{/each}}
  </div>
</template>
~~~
<%= caption "client/views/posts/posts_list.html" %>

And post_item.html:
　次にpost_item.htmlを作ります。

~~~html
<template name="postItem">
  <div class="post">
    <div class="post-content">
      <h3><a href="{{url}}">{{title}}</a><span>{{domain}}</span></h3>
    </div>
  </div>
</template>
~~~
<%= caption "client/views/posts/post_item.html" %>

Note the name="postsList" attribute of the template element.
This is the name that will be used by Meteor to keep track of what template goes where.
　テンプレート要素の name="postsList"属性を書き込みます。
　これはどのテンプレートがどこに行くのか　（ keep track of？）するために、Meteorで使われている（ name？）です。

It's time to introduce Meteor's templating system, Spacebars. 
Spacebars is simply HTML, with the addition of three things: partials, expressions and block helpers.
　ここでMeteorのテンプレートシステム、Spacebarsについて紹介します。
　SpacebarsではHTMLに３つのものを付け加えます：partialsとexpressionsとblock helpersです。

Partials use the {{> templateName}} syntax, 
and simply tell Meteor to replace the partial with the template of the same name (in our case postItem).
　Partialsでは{{> templateName}}構文を使い、
　partialを同じ名前（ここではpostItem）のテンプレートに置き換えるようMeteorに命令します。
　

Expressions such as {{title}} either call a property of the current object, 
or the return value of a template helper as defined in the current template's manager (more on this later).
　{{title}}のようなExpressionsは、カレントオブジェクトのプロパティを呼び出すか、
　テンプレートマージャーで定義されている　テンプレートヘルパーの値を返します。（そのことについては後で述べます。）

Finally, block helpers are special tags that control the flow of the template, 
such as {{#each}}…{{/each}} or {{#if}}…{{/if}}.
　最後に、block helpersはテンプレートのフローを制御する特別なタグで、
　たとえば、{{#each}}…{{/each}} や {{#if}}…{{/if}}があります。

<% note do %>

### Going Further

You can refer to the Spacebars documentation if you'd like to learn more about Spacebars.
　Spacebarsについてさらに学びたいという場合は、Spacebarsドキュメンテーションを参照できます。

<% end %>

Armed with this knowledge, we can easily understand what's going on here.
　この知識が備わると、ここでどんなことが起こっているのか簡単に理解することができます。

First, in the postsList template, we're iterating over a posts object with the {{#each}}…{{/each}} block helper.
Then, for each iteration we're including the postItem template.
　最初にpostsListテンプレートの中で、{{#each}}…{{/each}} block helperを使ってpostsオブジェクトに繰り返し処理を行っています。
　eachイテレーションで、私たちはpostItemテンプレートを（including ？＝インクルード？）しています。

Where is this posts object coming from? Good question. 
It's actually a template helper, and we'll define it when we look at template managers.
　postsオブジェクトがどこからやって来たのでしょうか？　（Good question.？＝いいところに気がつきましたね。）
　それは実際のところ、テンプレートヘルパーからで、私たちはテンプレートマネージャーを見ているときにpostsオブジェクトを定義しました。

The postItem template itself is fairly straightforward. It only uses three expressions: 
{{url}} and {{title}} both return the document's properties, and {{domain}} calls a template helper.
　postItemテンプレート自体はかなり単純で、３つのexpressionしか使っていません：
　{{url}} と {{title}}は両方ともドキュメントのプロパティを返して、{{domain}}はテンプレートヘルパーを呼び出します。

We've mentioned "template helpers" a lot throughout this chapter without really explaining what they do. 
But in order to fix this, we must first talk about managers.
　私たちはこの章を通して「テンプレートヘルパー」がどんなことをしているか説明せずに多くのことを話してきました。
　しかし、この点を（fix？＝解決？）するためには、最初にマネージャーについて話さなければなりません。

### テンプレート Managers

Up to now we've been dealing with Spacebars, 
which is little more than HTML with a few tags sprinkled in. 
Unlike other languages like PHP (or even regular HTML pages, which can include JavaScript),
Meteor keeps templates and their logic separated, and these templates don't do much by themselves.
　ここまで私たちはSpacebarsについて取り組んできました。
　Spacebarsはいくつかのタグを散りばめたHTMLです。
　PHPのような他の言語と違って（あるいは、JavaScriptが含まれた通常のHTMLページでさえ）、
　Meteorはテンプレートと他のロジックを分離した状態にします。
　テンプレートそれ自体が分離させるわけではありません。（？？？）

In order to come to life, a template needs a manager.
You can think of the manager as the chef that takes raw ingredients (your data) and prepares them,
before handing out the finished dish to the waiter (the template) who then presents it to you.
　（ come to life？）するためには、テンプレートにマネージャーが必要です。
　　このマネージャーは　（finished dish？＝完成した料理を）をウェイター（テンプレート）に渡す前に
　　生の食材（データ）をとってきて、調理をするシェフのようなものと見なすことができます。

In other words, while the template's role is limited to displaying or looping over variables, 
the manager is the one who actually does the heavy lifting by assigning a value to each variable.
　言い換えれると、テンプレートの役割は表示をすることと変数をループすることに限定されまが、（？？？）
　マネージャーは　それぞれの変数に値を割り当てることで、重労働をしています。（？？？）　

<% note do %>

### Managers?

When we asked around to see what other Meteor developers called template managers, half said "controllers",
and half said "those files where I put my JavaScript code".
　私たちがMeteor開発者たちにテンプレートマネージャーを何と呼んでいるのか聞いて回ったところ、
　半分の人は「コントローラー」だと言い、もう半分の人は「JavaScriptのコードを置くファイル」だと言いました。

Managers aren't really controllers (at least, not in the sense of MVC controllers) 
and "TFWIPMJSC" isn't really that catchy, so we rejected both propositions.
　実際のところ、マネージャーはコントローラーではありません。
　（少なくとも、MVCでの意味のコントローラーではありません。）
　「JavaScriptのコードを置くファイル」と呼ぶのも受けが良さそうではありません。
　そのため、どちらの意見も却下しました。

Since we still wanted a way to indicate what we were talking about, 
we came up with the term "manager" as a handy shortcut 
that didn't have any pre-existing meaning as far as web frameworks are concerned.
　私たちは何と呼べばよいのかを決めたかったため、「マネージャー」という言葉を思いつきました。
　また、マネージャーという言葉はwebフレームワークに関係したこと以前から存在する意味がありませんでした。

<% end %>

To keep things simple, we'll adopt the convention of naming the manager after the template, 
except with a .js extension. 
So let's create posts_list.js inside /client/views/posts right away and start building our first manager:
  シンプルにするために、私たちはテンプレートに（after？＝ちなんだ？）マネージャーという名前の　（convention？）を採用しました。
  ただし、.js拡張子を省いています。（？？？）
  では早速、/client/views/postsの中にposts_list.jsを作って、最初のマネージャーを作っていきましょう。

~~~js
var postsData = [
  {
    title: 'Introducing Telescope',
    author: 'Sacha Greif',
    url: 'http://sachagreif.com/introducing-telescope/'
  }, 
  {
    title: 'Meteor',
    author: 'Tom Coleman',
    url: 'http://meteor.com'
  }, 
  {
    title: 'The Meteor Book',
    author: 'Tom Coleman',
    url: 'http://themeteorbook.com'
  }
];
Template.postsList.helpers({
  posts: postsData
});
~~~
<%= caption "client/views/posts/posts_list.js" %>

If you've done it right, you should now be seeing something similar to this in your browser:
　正しくできたら、ブラウザでは次のように表示されているでしょう。

Our first templates with static data
<%= screenshot "3-1", "静的データでの最初のテンプレート" %>

Added basic posts list template and static data
<%= commit "3-1", "基本的な（posts list template？）と静的なデータを（Added？＝組み込みました？）" %>

We're doing two things here. First we're setting up some dummy prototype data in the postsData array.
That data would normally come from the database, 
but since we haven't seen how to do that yet (wait for the next chapter) we're "cheating" by using static data.
　私たちはここで２つのことをしています。
　まず１つ目に　postsData配列の中でダミープロトタイプデータを構成しています。
　通常、データはデータベースからやって来ます。
　この点は次の章で学びますので、静的データを使って「ごまかして」います。

２つ目に postsをテンプレートヘルパーに定義するため、Meteorの Template.myTemplate.helpers()関数を使っています。
postsは、postsData配列を返します。

postsヘルパーを定義するということは、テンプレートでも使うことができるということです。

~~~html
<template name="postsList">
  <div class="posts">
    {{#each posts}}
      {{> postItem}}
    {{/each}}
  </div>
</template>
~~~
<%= caption "client/views/posts/posts_list.html" %>

そのため、このテンプレートではpostsData配列を繰り返し処理ができる　　postItemテンプレート内で　（？？？）

### "this"の値

私たちは今post_item.jsマネージャーを作りました。

~~~js
Template.postItem.helpers({
  domain: function() {
    var a = document.createElement('a');
    a.href = this.url;
    return a.hostname;
  }
});
~~~
<%= caption "client/views/posts/post_item.js" %>

<%= commit "3-2", "Setup a `domain` helper on the `postItem`." %>

今回のdomainヘルパーの値は配列ではなく、無名関数です。
このパターンは先ほどのダミーデータの例と比べて、より一般的で役立ちます。


<%= screenshot "3-2", "それぞれのリンクにドメインを表示する" %>

domainヘルパーはURLを取ってきて、ちょっとしたJavaScriptのマジックによってドメインを返します。
ですが、そもそもURLはどこから取ってきたのでしょうか？

この疑問に答えるには、 posts_list.htmlテンプレートまで戻る必要があります。
{{#each}}ブロックヘルパーは配列を繰り返し処理するだけではありません。
ブロックの中のthisの値を繰り返し処理されたオブジェクトに設定するのです。

////（？？？）

ここまでで、なぜthis.urlがpostのURLを返すのか理解できるでしょう。
また、post_item.html テンプレートの中の{{title}} と {{url}}を使う場合、　
Meteorはそれがthis.titleとthis.urlであることを認識し、正しい値を返します。

<% note do %>

### JavaScriptマジック

Meteorに限ったことではないのですが、ここで先ほどの「JavaScriptマジック」について解説しましょう。
まず、HTMLで空のアンカー要素(a)を作り、メモリに記憶します。

その時に　 postのURLと等しくなるようにhref属性を設定しています。
（このように、ヘルパーにおいて　this　は現在動作しているオブジェクトのことです。）・・・（？？？）

最後に、　　残りのURLがなくてもリンクのドメイン名を返すので、a要素のhostnameプロパティを使用しています。

<% end %>

ここまで理解ができたら、ブラウザでpostのリストを見ることができるでしょう。
そのリストは単なる静的データです。
そのため、まだMeteorのリアルタイムに関する特徴ついて使っていません。
次の章ではその点について見て行きましょう！

<% note do %>

### Hot Code Reload　・・（？？？）

ファイルを変えた際に手動でブラウザをリロードをする必要がないことにお気づきでしょうか。


これはMeteorがプロジェクトディレクトリ内で全てのファイルを読み込み、変更点を見つけると自動的にブラウザを更新するためです。

Meteorのホットコードリロードはとてもスマートであり、  アプリの状態を保存する　（？？？）

<% end %>
