---
title: Routing
slug: routing
date: 0005/01/01
number: 5
contents: Meteorでのルーティングを学びます。.| 固有のURLで投稿ディスカッションページを作ります。（？？？）|どうやって適切にURLをリンクするのか学習します。
paragraphs: 72
---

Now that we have a list of posts (which will eventually be user-submitted),
今のところ、投稿の一覧表があるので、（最終的にはユーザーが投稿するようにします）
we need an individual post page where our users will be able to discuss each post.
　ユーザー同士で投稿を議論できるように個別の投稿ページがほしいところです。（？？？）

We'd like these pages to be accessible via a permalink, 
a URL of the form http://myapp.com/posts/xyz (where xyz is a MongoDB _id identifier) that is unique to each post.
 このページをパーマリンクを通じて、アクセスできるようにしたいと思います。　
 パーマリンクとは http://myapp.com/posts/xyz の形をした URL で、 それぞれの投稿は独自のものです。　　（ xyz の部分は MongoDB の _id 識別子です）

This means we'll need some kind of routing to look at what's inside the browser's URL bar
and display the right content accordingly.
　これはブラウザーの URL バーの中に何があるのか調べてそれに応じて正しい中身を表示する何らかのルーティングが必要であるということです

### Iron Routerパッケージを入れる

Iron Router is a routing package that was conceived specifically for Meteor apps.
Iron Router は Meteor アプリでのルーティングに特化したパッケージです。

Not only does it help with routing (setting up paths), 
but it can also take care of filters (assigning actions to some of these paths) ]
and even manage subscriptions (control which path has access to what data).
　Iron Router はルーティング（パスの設定）に役立つだけではなく、
　パスに処理を割り当てるフィルターも処理します。
　また、どのパスがどんなデータにアクセスするのか制御するサブスクリプションも　操ります（？？？）　

(Note: Iron Router was developed in part by Discover Meteor co-author Tom Coleman.)

First, let's install the package from Atmosphere:
最初に、Atmosphere からパッケージをインストールしましょう。

~~~bash
$ meteor add iron:router
~~~
<%= caption "Terminal" %>

This command downloads and installs the iron-router package into our app, ready to use. 
Note that you might sometimes need to restart your Meteor app 
(with ctrl+c to kill the process, then meteor to start it again) before a package can be used.
　このコマンドで iron-router パッケージをアプリにダウンロードしてインストールをしたので、すぐに使える状態となります。
　パッケージを使う前に Meteor アプリを再起動する必要があるかもしれません。
（ctrl+c でプロセスを中止して、再び起動するために meteor を入力します。）

<% note do %>

### Router Vocabulary　ルーティング用語集

We'll be touching on a lot of different features of the router in this chapter. 
If you have some experience with a framework such as Rails, 
you'll already be familiar with most of these concepts.
But if not, here's a quick glossary to bring you up to speed
　この章では、ルーティングに関する様々な特徴に触れることになります。
　もしあなたが Rails などのフレームワークの経験があるなら、
　このコンセプトについてすでに知っていることでしょう。
　もしそうでなければ、ここでちょっとした用語集を用意しました。

Routes: A route is the basic building block of routing.
It's basically the set of instructions that tell the app where to go and what to do when it encounters a URL.
Paths: A path is a URL within your app. 
It can be static (/terms_of_service) or dynamic (/posts/xyz), 
and even include query parameters (/search?keyword=meteor).
Segments: The different parts of a path, delimited by forward slashes (/).
Hooks: Hooks are actions that you'd like to perform before, after, or even during the routing process. 
A typical example would be checking if the user has the proper rights before displaying a page.
Filters: Filters are simply hooks that you define globally for one or more routes.
Route Templates: Each route needs to point to a template. 
If you don't specify one, the router will look for a template with the same name as the route by default.
Layouts: You can think of layouts as one of those digital photo frames. 
They contain all the HTML code that wraps the current template, and will remain the same even if the template changes.
Controllers: Sometimes, you'll realize that a lot of your templates are reusing the same parameters. 
Rather than duplicate your code, 
you can let all these routes inherit from a single routing controller which will contain all the routing logic.

- ルート：ルートとは、ルーティングの基本的な構成要素です。
　　　　アプリが URL と遭遇した際に（？？？）どこに行ったらよいか、何をしたらよいかといった基本的な命令のセットがルートです。
- パス：パスとはアプリ内での URL のことです。　パスは静的な(/terms_of_service) や動的な(/posts/xyz)、質問パラメーターでもあります。
- セグメント：パスの様々なパーツのことで、前のスラッシュ（/）で区切れています。
- フック：フックとは、　（？？？）
　　　　　代表的な例は、　ユーザーがページを表示する前に適切な権利を持っているか調べます。（？？？）
- フィルター：フィルターとは、一個以上のルートをグローバルに定義するシンプルなフックです。（？？？）　　
- ルートテンプレート： 各ルートはテンプレートを指し示します。
　　　　　　　　　　　　（？？？）、デフォルトでのルーターは、ルートとしての同じ名前のテンプレートを探します。（？？？）
- レイアウト：レイアウトとは、デジタルフォトフレームのようなものだと捉えることができます。
　　　　　　　レイアウトは　　現在のテンプレートをラップする（？？？）　すべての HTML コードのことで、テンプレートが変化しても同じ状態を保ちます。　　
- コントローラー：時々、　多くのテンプレートが同じパラメーターで（？？？）再利用できることに気づくでしょう。
　　　　　　　　　コードを繰り返すよりも（？？？）、　　１つのルーティングコントローラーで　ルートを継承することができます。（？？？）

For more information about Iron Router, check out the full documentation on GitHub.
Iron Routerに関する情報は、GitHub 上でドキュメンテーションの全文を見ることができます。

<% end %>

### Routing: Mapping URLs To Templates

So far, we've built our layout using hard-coded template includes (such as {{>postsList}}). 
So although the content of our app can change,the page's basic structure is always the same:
 a header, with a list of posts below it.
今まで、{{>postsList}}のようにハードコードされたテンプレートのインクードを使ってレイアウトを作ってきました。（？？？）
そのため、アプリの内容は変化しましたが、ページの基本的な構造は常に同じです。
つまり、ヘッダーと投稿の一覧表です。（？？？）

The Iron Router lets us break out of this mold by taking over what renders inside the HTML <body> tag.
So we won't define that tag's content ourselves, as we would with a regular HTML page. 
Instead, we will point the router to a special layout template that contains a {{> yield}} template helper.
　Iron Router は HTML の <body> タグの中をレンダリングしたものを引き継ぐことで、この型から抜け出します。（？？？）
　そのため、通常の HTML ページのようにタグの中を定義しません。（？？？）
その代わりに、{{> yield}} テンプレートヘルパーを含んだ特別なレイアウトテンプレートをルーターに指定します（？？？）

This {{> yield}} helper will define a special dynamic zone that
will automatically render whichever template corresponds to the current route
(as a convention, we'll designate this special template as the “route template” from now on):
この {{> yield}} ヘルパーは　現在のルートに対応するどんなテンプレートでも自動的にレンダリングする特別な動的な区間を定義します（？？？）

<%= diagram "router-diagram", "レイアウトとテンプレート.", "pull-center" %>

We'll start by creating our layout and adding the {{> yield}} helper. 
First, we'll remove our HTML <body> tag from main.html, and move its contents to their own template, layout.html.
ではレイアウトを作って {{> yield} }ヘルパーを追加してみましょう。
はじめに、main.html から HTML の <body> タグを削除して、その中身を layout.htmlの中のテンプレートに移動させます。（？？？）

So our slimmed down main.html now looks like this:
すると、スリムになった main.html は現在このようになっています。

~~~html
<head>
  <title>Microscope</title>
</head>
~~~
<%= caption "client/main.html" %>

While the newly created layout.html will now contain the app's outer layout:
新しく作った layout.html は現在、アプリの外側のレイアウトを含んでいます。（？？？）

~~~html
<template name="layout">
  <div class="container">
  <header class="navbar">
    <div class="navbar-inner">
      <a class="brand" href="/">Microscope</a>
    </div>
  </header>
  <div id="main" class="row-fluid">
    {{yield}}
  </div>
  </div>
</template>
~~~
<%= caption "client/views/application/layout.html" %>

You'll notice we've replaced the inclusion of the postsList template with a call to yield helper. 
You'll notice that after this change, we see nothing on the screen. 
This is because we haven't told the router what to do with the / URL yet, so it simply serves up an empty template.
postsList テンプレートを yield ヘルパーの呼び出しに交換したことに気づいたことでしょう。
また、その変化の後にスクリーン上になにもないことにお気づきかと思います。
これはまだ　ルーターに/ URLで何を処理するか命令していないためです。
そのため空のテンプレートを出しています。

To begin, we can regain our old behavior by mapping the root / URL to the postsList template.
We'll create a /lib directory at our project's root, and inside it create router.js :
　はじめに、postsList テンプレートに/ URL ルートを割り当てることで、（ regain our old behavior？）
　ルートのプロジェクトで /lib directory を作って、その中に router.js を作ります。

~~~js
Router.configure({
  layoutTemplate: 'layout'
});

Router.map(function() {
  this.route('postsList', {path: '/'});
});
~~~
<%= caption "lib/router.js"%>

We've done two important things. 
First, we've told the router to use the layout we just created as the default layout for all routes.
Second, we've defined a new route called postsList and mapped it to the / path.
　これで２つの大事なことを行いました。
　１つめは、ルーターに　（？？？）　　レイアウトを使うことを命令しました。
　２つめは、postsList という名前の新しいルートを定義して、/ パスを割り当てました。

<% note do %>

### The `/lib` folder

Anything you put inside the /lib folder is guaranteed to load first before anything else in your app
(with the possible exception of smart packages).
This makes it a great place to put any helper code that needs to be available at all times.
 /lib フォルダ内に置いたものは、何よりも前に最初に読み込まれることを保証します。（？？？）
（スマートパッケージは例外です）。
そのため、/lib フォルダはいつも利用する必要のあるヘルパーコードを置く最適な場所となります。

A bit of warning though: note that since the /lib folder is neither inside /client or /server,
this means its contents will be available to both environments.
しかし、注意点が１つあります。 /lib フォルダは /client 、/server 内のどちらにもないので、（？？？）
/lib フォルダの内容がどちらの環境でも有効化されるということに気をつけます。

<% end %>

### Named Routes

Let's clear up a bit of ambiguity here. 
We named our route postsList, but we also have a template called postsList. So what's going on here?
　ここで少しあいまいな点をクリアにしましょう。
　私たちはルートに postsList と名付けましたが、postsList という名前のテンプレートもあります。
すると、ここではどんなことが起こるのでしょうか。

By default, Iron Router will look for a template with the same name as the route. 
In fact, it will even look for a path based on the route name, 
meaning that if we hadn't defined a custom path (which we did by providing a path option in our route definition), 
our template would've been accessible at URL /postsList by default.
　デフォルトの状態だと、 Iron Router はルートで同じ名前のテンプレートを探します。（？？？）
実際には、カスタムパス（？？？）を定義していなくても　ルートの名前に基づいたパスを探します。
（つまり、　ルートの定義にパスの選択肢を与えました。）（？？？）
テンプレートはデフォルト状態では　/postsList の URL でアクセスできます。（？？？）

You may be wondering why we even need to name our routes in the first place.
Naming routes lets us use a few Iron Router features that make it easier to build links inside our app.
The most useful one is the {{pathFor}} Spacebars helper, which returns the URL path component of any route.
なぜ最初の段階でルートに名前をつける必要があるのか不思議に思う読者の方もいるかもしれません。
ルートを名付けることでアプリ内で簡単にリンクを作る Iron Router の特徴を使うことができます。　
最も役立つ特徴は {{pathFor}} という Spacebars ヘルパーです。これはどんなルートでも URL パスの構成要素を返します。（？？？）

We want our main home link to point us back to the posts list, 
so instead of specifying a static / URL, we can also use the Spacebars helper.
The end result will be the same,
but this gives us more flexibility since the helper will always output the right URL even if 
we change the route's path in the router.
メインのホームのリンクが（？？？）投稿の一覧を返すようにしたいので、（？？？）
静的な / URL を指定する代わりに、Spacebars ヘルパーを使います。
最終的な結果は同じとなりますが、ルーターでルートのパスを変えたとしてもヘルパーは常に正しい URL を出力するため、
私たちはフレキシビリティを得ることができます。

~~~html
<header class="navbar">
  <div class="navbar-inner">
    <a class="brand" href="{{pathFor 'postsList'}}">Microscope</a>
  </div>
</header>

//...
~~~
<%= caption "client/views/application/layout.html"%>
<%= highlight "3" %>

<%= commit "5-1", "Very basic routing." %>

### Waiting on Data

If you deploy the current version of the app (or launch the instance using the link above), 
you'll notice that the list appears empty for a few moments before the posts appear. 
This is because when the page first loads, 
there are no posts to display until the posts subscription is done grabbing the post data from the server.
　もし現在の状態のアプリをデプロイしたら、（あるいは上記のリンクを使ってインスタンスをローンチしたら）
　投稿が現れる前のわずかな間はリストの中身がないことに気づくことだと思います。
　これはページが最初に読み込まれるときはpostsサブスクリプションがサーバーから投稿データを取ってくるまで表示する投稿がないからです。（？？？）

It would be a much better user experience to provide some visual feedback that something is happening, 
and that the user should wait a moment.
　何が起きているのかという視覚的なフィードバックを与えるので（？？？）　よりよいユーザーエクスペリエンスとなります。
そのためユーザーは少しの間待ってくれるでしょう。（？？？）

Luckily, Iron Router gives us an easy way to do that -- we'll waitOn the subscription:
幸運なことに、Iron Router にはそうするための簡単な方法があります。　waitOn サブスクリプションです。

~~~js
Router.configure({
  layoutTemplate: 'layout',
  loadingTemplate: 'loading',
  waitOn: function() { return Meteor.subscribe('posts'); }
});

Router.map(function() {
  this.route('postsList', {path: '/'});
});
~~~
<%= caption "lib/router.js" %>
<%= highlight "3,4" %>

Let's break things down. First, we've modified the Router.configure() block to provide the router
with the name of a loading template (which we'll create soon) 
to redirect to while our app is waiting for data.
ひとつひとつ見ていきましょう。
最初に、私たちは Router.configure() ブロックを修正しました。
ルーターに 読み込まれるテンプレート（これからすぐに作ります。）の名前を与えるために
アプリがデータを待っている間にリダイレクトする　　　（？？？？？？）

Second, we've also added a waitOn function, which returns our posts subscription.
Finally, we enabled a built in loading hook. 
What this means is that the router will ensure that the posts subscription is loaded 
before sending the user through to the route they requested.
次に、waitOn関数を加えました。waitOn関数は posts サブスクリプションを返します。
最後に、ローディングする（？？？）フックを作ることができました。
これは　ルーターは　ルートを通じてユーザーに送る前に　posts サブスクリプションが読み込まれることを確かにします。（？？？）

Note that since we're defining our waitOn function globally at the router level,
this sequence will only happen once when a user first accesses your app. 
After that, the data will already be loaded in the browser's memory and the router won't need to wait for it again.
私たちは waitOn関数をルーターレベルでグローバルに定義しているため、
この（？？？）は、ユーザーが初めてアプリにアクセスした際に一度だけ起こります。（？？？）
その後、データは　ブラウザーのメモリにすでに読み込まれ、ルータはは再び待つ必要がなくなります。

And since we are now letting the router handle our subscription, 
you can now safely remove it from main.js (which should now be empty).
これでルーターがサブスクリプションを処理するようにしたので、
main.js から（？？？）を安全に削除することができます。

It's usually a good idea to wait on your subscriptions, not just for the user experience, 
but also because it means you can safely assume that data will always be available from within a template. 
This eliminates the need to deal with templates being rendered before their underlying data is available,
which often requires tricky workarounds.
サブスクリプションを待つことはユーザーエクスペリエンスのためだけではなく、良いアイデアです　（？？？）
その理由は、データは常にテンプレート内から利用できるようにするためです。
基礎的な情報が利用できる前にレンダリングしたテンプレートを処理する必要がなくなります。（？？？）
扱いにくい回避方法が必要です。（？？？）

We'll also add an onBeforeAction filter to trigger Iron Router's built-in loading hook 
and make sure we're showing the loading template while we wait.
 また、onBeforeAction フィルターを加えます。Iron Router に組み込まれた loading フックを動作させます。
 そして、読み込まれるテンプレートを表示しています。（？？？）

The final piece of the puzzle is the actual loading template. 
We'll use the spin package to create a nice animated loading spinner.
Add it with mrt add spin, and then create the loading template as follows:
パズルの最後のピースは実際の読み込むテンプレートです。（？？？）
ナイスなローディングスピナーのアニメーションを作って spin パッケージを使います。（？？？）
mrt add spin で spin を入れて（？？？）、loading テンプレートを次のように作ります。

~~~html
<template name="loading">
  {{>spinner}}
</template>
~~~
<%= caption "client/views/includes/loading.html" %>

Note that {{>spinner}} is a partial contained in the spin package.
Even though this partial comes from “outside” our app, we can include it just like any other template.
{{>spinner}}　spin パッケージに含まれている部分です（？？？）。
この部分はプリの「外側」から来ているわけですが（？？？）、　普通のテンプレートと同様にインクルードすることができます。

<%= commit "5-2", "Wait on the post subscription." %>

<% note do %>

A First Glance At Reactivity

Reactivity is a core part of Meteor, and although we've yet to really touch on it,
our loading template gives us a first glance at this concept.

Redirecting to a loading template if data isn't loaded yet is all well and good, 
but how does the router know when to redirect the user back to the right page once the data comes through?

For now, let's just say that this is exactly where reactivity comes in, and leave it at this.
But don't worry, you'll learn more about it very soon!

### A First Glance At Reactivity

リアクティビリティは Meteor の根幹をなす部分ですが、ここまで触れてきませんでした。（？？？）
ローディングテンプレートは（？？？）このコンセプトについて少しだけ見せてくれることになりました。（？？？）

データがロードされていないかどうか　ローディングテンプレートにリダイレクトすることは良いことですが、
いつ ユーザーが正しいページに リダイレクトするのか　ルーターはどのように知ることになるのでしょうか。（？？？）　

今のところはとりあえず　リアクティビリティがその役割をしている　　とだけ言っておきましょう。
このことについてはこの後すぐに学びますので、心配は無用ですよ！（？？？）

<% end %>

###　特定の投稿にルーティングする

Now that we've seen how to route to the postsList template,
let's set up a route to display the details of a single post.
ここまでで、どのように postsList テンプレートにルーティングするのか見てきました。
ここでは１つ１つの投稿の詳細を表示するためのルートをセットアップしましょう。　（？？？）

There's just one catch: we can't go ahead and define one route per post, since there might be hundreds of them.
So we'll need to set up a single dynamic route, and make that route display any post we want.
（？？？）：　　１つの投稿ごとにルートの定義をするとなると、数百の投稿に対して同じことをすることになり、先に進めなくなってしまいます。
そのため、１つの動的なルートをセットアップして、ルートに私たちが見たい投稿を表示させる必要があります。

To start with, 
we'll create a new template that simply renders the same post template 
that we used earlier in the list of posts.
まず初めに、。私たちが以前使った同じ投稿テンプレートを（？？？）　投稿のリスト内でレンダリングする　　新しいテンプレートを作ります。

~~~html
<template name="postPage">
  {{> postItem}}
</template>
~~~
<%= caption "client/views/posts/post_page.html" %>

We'll add more elements to this template later on (such as comments),
but for now it'll simply serve as a shell for our {{> postItem}} include.
後でこのテンプレートにはコメントなどの要素を入れていきますが、今のところ {{> postItem}} インクルードのシェルのような役目を果たしています。

We are going to create another named route,
this time mapping URL paths of the form /posts/<ID> to the postPage template:
また違う名前でルートを作っていきましょう。
今回は、/posts/<ID> の形の（？？？） URL パスを postPage テンプレートに割り当てます。

~~~js
Router.map(function() {
  this.route('postsList', {path: '/'});
  
  this.route('postPage', {
    path: '/posts/:_id'
  });
});

~~~
<%= caption "lib/router.js" %>
<%= highlight "4~6" %>

The special :_id syntax tells the router two things:
first, to match any route of the form /posts/xyz/, where “xyz” can be anything at all.
Second, to put whatever it finds in this “xyz” spot inside an _id property in the router's params array.
特別な:_id構文はルーターに２つのことを命令しています：
１つは、　/posts/xyz/ の形のルートをマッチさせて、　“xyz” は何にもなりません。（？？？）
２つは、　ルーターの params配列で _id プロパティ内の “xyz” 地点を見つけたものはなんでも中に入れます。（？？？）

Note that we're only using _id for convenience's sake here. 
The router has no way of knowing if you're passing it an actual _id, or just some random string of characters.
 ここでは便宜上のために _id だけを使っていることに
 このルーター　あなたが実際の _id を押しているのか（？？？）、ランダムの文字列なのかは識別することはできません。（？？？）

We're now routing to the correct template, but we're still missing something: 
the router knows the _id of the post we'd like to display,
but the template still has no clue. So how do we bridge that gap?
私たちは今、正しいテンプレートにルーティングしていますが、まだ何かミスをしています：
ルーターは私たちが表示したい投稿の _id を識別します。
しかし、そのテンプレートはまだ何もわからない状態です。では、どのようにしてこのギャップを埋めるのでしょうか。

Thankfully, the router has a clever built-in solution: 
it lets you specify a template's data context. 
You can think of the data context as the filling inside a delicious cake made of templates and layouts. 
Simply put, it's what you fill up your template with:
ありがたいことに、このルーターには組み込まれた解決策があります：
（？？？）は、テンプレートのデータ内容を特定できます。
このデータコンテキストはテンプレートとレイアウトで作られたおいしいケーキの中を満たしているものようなものだと考えることができます。（？？？）
簡単に言いますと、 テンプレートの中をいっぱいに満たしているものがデータコンテキストです。（？？？）

<%= diagram "router-diagram-2", "データコンテキスト", "pull-center" %>

In our case, we can get the proper data context by looking for our post based on the _id we got from the URL:
この場合、私たちは URL から得た _id を基にした投稿を探して正しいデータコンテキストを得ています

~~~js
Router.map(function() {
  this.route('postsList', {path: '/'});
  
  this.route('postPage', {
    path: '/posts/:_id',
    data: function() { return Posts.findOne(this.params._id); }
  });
});

~~~
<%= caption "lib/router.js" %>
<%= highlight "4~7" %>

So every time a user accesses this route, 
we'll find the appropriate post and pass it to the template.
Remember that findOne returns a single post that matches a query, 
and that providing just an id as an argument is a shorthand for {_id: id}.
そのため、ユーザーがこのルートにアクセスするたびに、
私たちは　適切な投稿を見つけて その情報テンプレートに引き渡しています。（？？？）
findOne がクエリにマッチした１つの投稿を返して、
　　id が {_id: id} を略した表現であることに（？？？）


Within the data function for a route, this corresponds to the currently matched route, 
and we can use this.params to access the named parts of the route 
(which we indicated by prefixing them with : inside our path).
ルートの data 関数内で、this は現在マッチしたルートに対応しています。
私たちは名前がついたルートの部分にアクセスするために this.params を使うことができます。
（そのことを、私たちは path の中で：を前に置くことで表現しています。）（？？？）

<% note do %>

### More About Data Contexts

By setting a template's data context, you can control the value of this inside template helpers.
テンプレートのデータコンテキストを設定することで、テンプレートヘルパー内での this の値をコントロールすることができます。

This is usually done implicitly with the {{#each}} iterator, 
which automatically sets the data context of each iteration to the item currently being iterated on:
これは {{#each}} イテレータで間接的に処理されます。
こうして　自動的に　それぞれの繰り返し処理の データコンテキストを　（？？？）に設定します。 　（？？？？？？）

~~~html
{{#each widgets}}
  {{> widgetItem}}
{{/each}}
~~~

But we can also do it explicitly using {{#with}}, 
which simply says "take this object, and apply the following template to it". 
For example, we can write:
しかし、{{#with}} を使うことでも間接的に同じことができます。（？？？）
これは単純に「このオブジェクトを取ってきて、次のテンプレートにそれを適用しろ」と命令しています。
例えば、このように書くことができます。

~~~html
{{#with myWidget}}
  {{> widgetPage}}
{{/with}}
~~~

It turns out you can achieve the same result by passing the context as an argument to the template call. 
So the previous block of code can be rewritten as:
テンプレート（？？？）に、コンテキストを引数として引き渡すことで　同じ結果を得ることができることがわかりました。　
そのため以前のコードのブロックはこのように書きなおすことができます：

~~~js
{{> widgetPage myWidget}}
~~~

<% end %>

### Using a Dynamic Named Route Helper

Finally, we need to make sure that we're pointing to the right place whenever we want to link to an individual post.
Again, we could do something like <a href="/posts/{{_id}}">, but using a route helper is just more reliable.
最終的に、私たちは個別の投稿にリンクをしたい時はいつでも正しい場所を指し示す必要があります。（？？？）
再び、私たちは　<a href="/posts/{{_id}}"> のようにしてすることができますが（？？？）、ルートヘルパーを使った方がより確実です。

We've named the post route postPage, so we can use a {{pathFor 'postPage'}} helper:
私たちは投稿ルートを postPage と名付けました。そのため、{{pathFor 'postPage'}}ヘルパーを使います。

~~~html
<template name="postItem">
  <div class="post">
    <div class="post-content">
      <h3><a href="{{url}}">{{title}}</a><span>{{domain}}</span></h3>
    </div>
    <a href="{{pathFor 'postPage'}}" class="discuss btn">Discuss</a>
  </div>
</template>
~~~
<%= caption "client/views/posts/post_item.html"%>
<%= highlight "6" %>
<%= commit "5-3", "Routing to a single post page." %>

But wait, how exactly does the router know where to get the xyz part in /posts/xyz?
After all, we're not passing it any _id.
でも待ってください。　　/posts/xyzの中のどこでxyz部分を得るのか（？？？）ルーターはどれだけ正確に識別するのでしょうか。
結局、私たちは_idを引き渡していません。（？？？）

It turns out that Iron Router is smart enough to figure it out by itself. 
We're telling the router to use the postPage route,
and the router knows that this route requires an _id of some kind (since that's how we defined our path) .
Iron Routerは自分自身でそれを判断できるほど頭が良いことがわかりました。
私たちは　ルーターに　postPageルートを使うように命令しています。　
ルーターはルートがどこの_idを要求するのか　識別します。　（そのため、私たちはpathを適宜しました。）

So the router will look for this _id in the most logical place available: 
the data context of the {{pathFor 'postPage'}} helper, in other words this. 
And it so happens that our this corresponds to a post, which (surprise!) does possess an _id property.
そのため、ルーターは最もロジカルな場所で利用できる_idを探します：（？？？）
{{pathFor 'postPage'}} ヘルパーのデータコンテキスト、つまりはthisです。
thisは投稿に対応するため、（驚くことに！）_idプロパティも内包しているのです。（？？？）

Alternatively, you can also explicitely tell the router where you'd like it to look for the _id property, 
by passing a second argument to the helper (i.e. {{pathFor 'postPage' someOtherPost}}).
A practical use of this pattern would be getting the link to the previous or next posts in a list, for example.
その代わりに、ヘルパーに２つの引数を渡すことで（つまり、 {{pathFor 'postPage' someOtherPost}}として）
ルーターがどこで_idプロパティを探したいかを間接的に命令することもできます。（？？？）
たとえば、このパターンの実践的な使い方は 前や次の投稿へのリンクを一覧表として得ています。（？？？）

To see if it works correctly,
browse to the post list and click on one of the 'Discuss' links. You should see something like this:
正しく動作しているか確かめるために、
　投稿リストを（？？？）して、'Discuss' ボタンをクリックしてみます。
　きっとこのように表示されるはずです。

<%= screenshot "5-2", "A single post page." %>

<% note do %>

### HTML5 pushState

One thing to realise is that these URL changes are happening using HTML5 pushState.
（？？？）は、URLの変化はHTML5のpushStateを使うことで起こっています。（？？？）

The Router picks up clicks on URLs that are internal to the site,
and prevents the browser from browsing away from the app, 
instead just making the necessary changes to the app's state.
ルーターは　サイト内のURL　クリックを取得します。（？？？）
そして、ブラウザーがアプリから（？？？）することを防ぎます。
その代わりに、　アプリの状態の変化　　必要性　（？？？）

If everything is working correctly the page should change instantaneously. 
In fact, sometimes things change so fast that some kind of page transition might be needed. 
This is outside of the scope of this chapter, but an interesting topic nonetheless.
もしすべてが正しく動いているなら、ページは瞬時に変化します。
実際には、変化するのが早過ぎるため、ある種のページ推移が必要になります。（？？？）
これはこの章の範囲外のことですが、面白いトピックです。

<% end %>
