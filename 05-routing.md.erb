---
title: Routing
slug: routing
date: 0005/01/01
number: 5
contents: Meteorでのルーティングを学びます。.| ユニークなURLで投稿ディスカッションページを作ります。（？？？）|どうやって適切にURLをリンクするのか学習します。
paragraphs: 72
---

Now that we have a list of posts (which will eventually be user-submitted),
今のところ、投稿の一覧表があります（最終的にはユーザーが投稿するようにします）
we need an individual post page where our users will be able to discuss each post.
　ユーザーがお互いの投稿を議論できるように個別の投稿ページが必要です。（？？？）

We'd like these pages to be accessible via a permalink, 
このページをパーマリンクを通じて、　アクセスできるようにしたい　
a URL of the form http://myapp.com/posts/xyz (where xyz is a MongoDB _id identifier) that is unique to each post.
パーマリンクとはhttp://myapp.com/posts/xyz の形をしたURLで、 それぞれの投稿を独自のものにします（？？？）　　（xyzの部分はMongoDBの_id識別子です）

This means we'll need some kind of routing to look at what's inside the browser's URL bar
これは　　ブラウザーのURLバーの中に何があるのか調べてそれに応じて正しい中身を表示する何らかのルーティングが必要であるということです
and display the right content accordingly.


### Iron Routerパッケージを入れる

Iron Router is a routing package that was conceived specifically for Meteor apps.
Iron Router 特にMeteorアプリでのルーティングのパッケージです。

Not only does it help with routing (setting up paths), 
Iron Routerはルーティング（パスの設定）に役立つだけではなく、
but it can also take care of filters (assigning actions to some of these paths) 
パスに処理を割り当てるフィルターも処理します。
and even manage subscriptions (control which path has access to what data).
また、どのパスがどんなデータにアクセスするのか制御するサブスクリプションも　操ります（？？？）　

(Note: Iron Router was developed in part by Discover Meteor co-author Tom Coleman.)

First, let's install the package from Atmosphere:
最初に、Atmosphereからパッケージをインストールしましょう。

~~~bash
$ mrt add iron-router
~~~
<%= caption "Terminal" %>

This command downloads and installs the iron-router package into our app, ready to use. 
このコマンドでiron-routerパッケージをアプリにインストールします。　すぐ使える（？？？）
Note that you might sometimes need to restart your Meteor app 
パッケージを使う前にMeteorアプリを再起動する必要があるかもしれません　（？？？）
(with ctrl+c to kill the process, then meteor to start it again) before a package can be used.
（ctrl+cでプロセスを中止して、再び起動するためにmeteorを入力します。）

Note that the Iron Router is a third-party package,
Iron Routerはサードパーティのパッケージですので、
meaning that you'll need Meteorite to install it (meteor add iron-router won't work).
インストールするにはMeteoriteが必要です。(meteor add iron-router ではインストールできません).

<% note do %>

### Router Vocabulary　ルーティング用語集

We'll be touching on a lot of different features of the router in this chapter. 
この章では、ルーティングに関する様々な特徴に触れることになります。
If you have some experience with a framework such as Rails, 
もしあなたがRailsなどのフレームワークの経験があるなら、
you'll already be familiar with most of these concepts.
このコンセプトについてすでに知っていることでしょう。
But if not, here's a quick glossary to bring you up to speed
もしそうでなければ、ここでちょっとした用語集を用意しました。

Routes: A route is the basic building block of routing.
It's basically the set of instructions that tell the app where to go and what to do when it encounters a URL.
Paths: A path is a URL within your app. 
It can be static (/terms_of_service) or dynamic (/posts/xyz), 
and even include query parameters (/search?keyword=meteor).
Segments: The different parts of a path, delimited by forward slashes (/).
Hooks: Hooks are actions that you'd like to perform before, after, or even during the routing process. 
A typical example would be checking if the user has the proper rights before displaying a page.
Filters: Filters are simply hooks that you define globally for one or more routes.
Route Templates: Each route needs to point to a template. 
If you don't specify one, the router will look for a template with the same name as the route by default.
Layouts: You can think of layouts as one of those digital photo frames. 
They contain all the HTML code that wraps the current template, and will remain the same even if the template changes.
Controllers: Sometimes, you'll realize that a lot of your templates are reusing the same parameters. 
Rather than duplicate your code, 
you can let all these routes inherit from a single routing controller which will contain all the routing logic.

- ルート：ルートとは、ルーティングの基本的な構成要素です。
　　　　アプリがURLと遭遇した際に（？？？）どこに行ったらよいか、何をしたらよいかといった基本的な命令のセットがルートです。
- パス：パスとはアプリ内でのURLのことです。　パスは静的な(/terms_of_service) や動的な(/posts/xyz)、質問パラメーターでもあります。
- セグメント：パスの様々なパーツのことで、前のスラッシュ（/）で区切れています。
- フック：フックとは、　（？？？）
　　　　　代表的な例は、　ユーザーがページを表示する前に適切な権利を持っているか調べます。（？？？）
- フィルター：フィルターとは、一個以上のルートをグローバルに定義するシンプルなフックです。（？？？）　　
- ルートテンプレート： 各ルートはテンプレートを指し示します。
　　　　　　　　　　　　（？？？）、デフォルトでのルーターは、ルートとしての同じ名前のテンプレートを探します。（？？？）
- レイアウト：レイアウトとは、デジタルフォトフレームのようなものだと捉えることができます。
　　　　　　　レイアウトは　　現在のテンプレートをラップする（？？？）　全てのHTMLコードのことで、テンプレートが変化しても同じ状態を保ちます。　　
- コントローラー：時々、　多くのテンプレートが同じパラメーターで（？？？）再利用できることに気づくでしょう。
　　　　　　　　　コードを繰り返すよりも（？？？）、　　１つのルーティングコントローラーで　ルートを継承することができます。（？？？）

For more information about Iron Router, check out the full documentation on GitHub.
Iron Routerに関する情報は、GitHub上でドキュメンテーションの全文を見ることができます。

<% end %>

### Routing: Mapping URLs To Templates

So far, we've built our layout using hard-coded template includes (such as {{>postsList}}). 
So although the content of our app can change,the page's basic structure is always the same:
 a header, with a list of posts below it.
今まで、{{>postsList}}のようにハードコードされたテンプレートのインクードを使ってレイアウトを作ってきました。（？？？）
そのため、アプリの内容は変化しましたが、ページの基本的な構造は常に同じです。
ヘッダーと投稿の一覧表です。（？？？）

The Iron Router lets us break out of this mold by taking over what renders inside the HTML <body> tag.
So we won't define that tag's content ourselves, as we would with a regular HTML page. 
Instead, we will point the router to a special layout template that contains a {{> yield}} template helper.
Iron Routerは　HTMLの<body>タグの中をレンダリングしたものを（？？？）引き継ぐことで、この型から抜け出します。（？？？）
そのため、通常のHTMLページのようにタグの中を定義しません。（？？？）
その代わりに、　{{> yield}}テンプレートヘルパーを含んだ特別なレイアウトテンプレートをルーターに指定します（？？？）

This {{> yield}} helper will define a special dynamic zone that
will automatically render whichever template corresponds to the current route
(as a convention, we'll designate this special template as the “route template” from now on):
この{{> yield}}ヘルパーは　現在のルートに対応するどんなテンプレートでも自動的にレンダリングする特別な動的な区間を定義します（？？？）

<%= diagram "router-diagram", "レイアウトとテンプレート.", "pull-center" %>

We'll start by creating our layout and adding the {{> yield}} helper. 
First, we'll remove our HTML <body> tag from main.html, and move its contents to their own template, layout.html.
ではレイアウトを作って{{> yield}}ヘルパーを追加してみましょう。
はじめに、main.htmlからHTMLの<body>タグを削除して、その中身をlayout.htmlの中のテンプレートに移動させます。（？？？）

So our slimmed down main.html now looks like this:
すると、スリムになったmain.htmlは現在このようになっています。

~~~html
<head>
  <title>Microscope</title>
</head>
~~~
<%= caption "client/main.html" %>

While the newly created layout.html will now contain the app's outer layout:
新しく作ったlayout.htmlは現在、アプリの外側のレイアウトを含んでいます。（？？？）

~~~html
<template name="layout">
  <div class="container">
  <header class="navbar">
    <div class="navbar-inner">
      <a class="brand" href="/">Microscope</a>
    </div>
  </header>
  <div id="main" class="row-fluid">
    {{yield}}
  </div>
  </div>
</template>
~~~
<%= caption "client/views/application/layout.html" %>

You'll notice we've replaced the inclusion of the postsList template with a call to yield helper. 
You'll notice that after this change, we see nothing on the screen. 
This is because we haven't told the router what to do with the / URL yet, so it simply serves up an empty template.
postsListテンプレートをyield ヘルパーの呼び出しに交換したことに　（？？？）
また、その変化の後にスクリーン上になにもないことにお気づきかと思います。
これはまだ　ルーターに/ URLで何を処理するか命令していないためです。
そのため空のテンプレートを出しています。

To begin, we can regain our old behavior by mapping the root / URL to the postsList template.
We'll create a /lib directory at our project's root, and inside it create router.js :
はじめに、　　postsListテンプレートに/ URLルートを割り当てて、（？？？）を
　ルートのプロジェクトで/lib directoryを作って、その中にrouter.jsを作ります。

~~~js
Router.configure({
  layoutTemplate: 'layout'
});

Router.map(function() {
  this.route('postsList', {path: '/'});
});
~~~
<%= caption "lib/router.js"%>

We've done two important things. 
First, we've told the router to use the layout we just created as the default layout for all routes.
Second, we've defined a new route called postsList and mapped it to the / path.
これで２つの大事なことが終わりました。
１つめは、ルーターに　（？？？）　　レイアウトを使うことを命令しました。
２つめは、postsListという名前の新しいルートを定義して、/ パスを割り当てました。

<% note do %>

### The `/lib` folder

Anything you put inside the /lib folder is guaranteed to load first before anything else in your app
(with the possible exception of smart packages).
This makes it a great place to put any helper code that needs to be available at all times.
 /libフォルダ内に置いたものは、　何よりも前に最初に読み込まれることを保証します。（？？？）
（スマートパッケージは例外ですが）。
そのため、/libフォルダはいつも利用する必要のあるヘルパーコードを置く最適な場所となります。

A bit of warning though: note that since the /lib folder is neither inside /client or /server,
this means its contents will be available to both environments.
しかし、注意点が１つあります。 /libフォルダは/client 、/server内のどちらにもないので、（？？？）
/libフォルダの内容がどちらの環境でも有効化されるということに気をつけます。

<% end %>

### Named Routes

Let's clear up a bit of ambiguity here. 
We named our route postsList, but we also have a template called postsList. So what's going on here?
ここで少しあいまいな点をクリアにしましょう。
私たちはルートにpostsListと名付けましたが、postsListという名前のテンプレートもあります。
すると、ここではどんなことが起こるのでしょうか。

By default, Iron Router will look for a template with the same name as the route. 
In fact, it will even look for a path based on the route name, 
meaning that if we hadn't defined a custom path (which we did by providing a path option in our route definition), 
our template would've been accessible at URL /postsList by default.
デフォルトの状態だと、 Iron Router はルートで同じ名前のテンプレートを探します。（？？？）
実際には、カスタムパス（？？？）を定義していなくても　ルートの名前に基づいたパスを探します。
（つまり、　ルートの定義にパスの選択肢を与えました。）（？？？）
テンプレートはデフォルト状態では　/postsListのURLでアクセスできます。（？？？）

You may be wondering why we even need to name our routes in the first place.
Naming routes lets us use a few Iron Router features that make it easier to build links inside our app.
The most useful one is the {{pathFor}} Spacebars helper, which returns the URL path component of any route.
なぜ最初の段階でルートに名前をつける必要があるのか不思議に思う読者の方もいるかもしれません。
ルートを名付けることでアプリ内で簡単にリンクを作るIron Router の特徴を使うことができます。　
最も役立つ特徴は{{pathFor}}というSpacebarsヘルパーです。これはどんなルートでもURLパスの構成要素を返します。（？？？）

We want our main home link to point us back to the posts list, 
so instead of specifying a static / URL, we can also use the Spacebars helper.
The end result will be the same,
but this gives us more flexibility since the helper will always output the right URL even if 
we change the route's path in the router.
メインのホームのリンクが（？？？）投稿の一覧を返すようにしたいので、（？？？）
静的な / URL を指定する代わりに、Spacebarsヘルパを使います。
最終的な結果は同じとなりますが、ルーターでルートのパスを変えたとしてもヘルパーは常に正しいURLを出力するため、
私たちはフレキシビリティを得ることができます。

~~~html
<header class="navbar">
  <div class="navbar-inner">
    <a class="brand" href="{{pathFor 'postsList'}}">Microscope</a>
  </div>
</header>

//...
~~~
<%= caption "client/views/application/layout.html"%>
<%= highlight "3" %>

<%= commit "5-1", "Very basic routing." %>

### Waiting on Data

If you deploy the current version of the app (or launch the instance using the link above), 
you'll notice that the list appears empty for a few moments before the posts appear. 
This is because when the page first loads, 
there are no posts to display until the posts subscription is done grabbing the post data from the server.
もし現在の状態のアプリをデプロイしたら、（あるいは上記のリンクを使ってインスタンスをローンチしたら）
投稿が現れる前のわずかな間はリストの中身がないことに気づくことだと思います。
これはページが最初に読み込まれるときはpostsサブスクリプションがサーバーから投稿データを取ってくるまで表示する投稿がないからです。（？？？）

It would be a much better user experience to provide some visual feedback that something is happening, 
and that the user should wait a moment.
何が起きているのかという視覚的なフィードバックを与えるので（？？？）　よりよいユーザーエクスペリエンスとなります。
そのためユーザーは少しの間待ってくれるでしょう。（？？？）

Luckily, Iron Router gives us an easy way to do that -- we'll waitOn the subscription:
幸運なことに、Iron Routerにはそうするための簡単な方法があります。　waitOnサブスクリプションです。

~~~js
Router.configure({
  layoutTemplate: 'layout',
  loadingTemplate: 'loading',
  waitOn: function() { return Meteor.subscribe('posts'); }
});

Router.map(function() {
  this.route('postsList', {path: '/'});
});
~~~
<%= caption "lib/router.js" %>
<%= highlight "3,4" %>

Let's break things down. First, we've modified the Router.configure() block to provide the router
with the name of a loading template (which we'll create soon) 
to redirect to while our app is waiting for data.
ひとつひとつ見ていきましょう。
最初に、私たちはRouter.configure()ブロックを修正しました。
ルーターに 読み込まれるテンプレート（これからすぐに作ります。）の名前を与えるために
アプリがデータを待っている間にリダイレクトする　　　（？？？？？？）

Second, we've also added a waitOn function, which returns our posts subscription.
Finally, we enabled a built in loading hook. 
What this means is that the router will ensure that the posts subscription is loaded 
before sending the user through to the route they requested.
次に、waitOn関数を加えました。waitOn関数はpostsサブスクリプションを返します。
最後に、ローディングする（？？？）フックを作ることができました。
これは　ルーターは　ルートを通じてユーザーに送る前に　postsサブスクリプションが読み込まれることを確かにします。（？？？）

Note that since we're defining our waitOn function globally at the router level,
this sequence will only happen once when a user first accesses your app. 
After that, the data will already be loaded in the browser's memory and the router won't need to wait for it again.
私たちはwaitOn関数をルーターレベルでグローバルに定義しているため、
この（？？？）は、ユーザーが初めてアプリにアクセスした際に一度だけ起こります。（？？？）
その後、データは　ブラウザーのメモリにすでに読み込まれ、ルータはは再び待つ必要がなくなります。

And since we are now letting the router handle our subscription, 
you can now safely remove it from main.js (which should now be empty).
これでルーターがサブスクリプションを処理するようにしたので、
main.jsから（？？？）を安全に削除することができます。

It's usually a good idea to wait on your subscriptions, not just for the user experience, 
but also because it means you can safely assume that data will always be available from within a template. 
This eliminates the need to deal with templates being rendered before their underlying data is available,
which often requires tricky workarounds.
サブスクリプションを待つことはユーザーエクスペリエンスのためだけではなく、良いアイデアです　（？？？）
その理由は、データは常にテンプレート内から利用できるようにするためです。
基礎的な情報が利用できる前にレンダリングしたテンプレートを処理する必要がなくなります。（？？？）
扱いにくい回避方法が必要です。（？？？）

We'll also add an onBeforeAction filter to trigger Iron Router's built-in loading hook 
and make sure we're showing the loading template while we wait.
 また、onBeforeActionフィルターを加えます。Iron Routerに組み込まれたloadingフックを動作させます。
 そして、読み込まれるテンプレートを表示しています。（？？？）

The final piece of the puzzle is the actual loading template. 
We'll use the spin package to create a nice animated loading spinner.
Add it with mrt add spin, and then create the loading template as follows:

~~~html
<template name="loading">
  {{>spinner}}
</template>
~~~
<%= caption "client/views/includes/loading.html" %>

////

<%= commit "5-2", "Wait on the post subscription." %>

<% note do %>

### A First Glance At Reactivity

////

////

////

<% end %>

### Routing To A Specific Post

////

////

////

~~~html
<template name="postPage">
  {{> postItem}}
</template>
~~~
<%= caption "client/views/posts/post_page.html" %>

////

////

~~~js
Router.map(function() {
  this.route('postsList', {path: '/'});
  
  this.route('postPage', {
    path: '/posts/:_id'
  });
});

~~~
<%= caption "lib/router.js" %>
<%= highlight "4~6" %>

////

////

////

////

<%= diagram "router-diagram-2", "The data context.", "pull-center" %>

////

~~~js
Router.map(function() {
  this.route('postsList', {path: '/'});
  
  this.route('postPage', {
    path: '/posts/:_id',
    data: function() { return Posts.findOne(this.params._id); }
  });
});

~~~
<%= caption "lib/router.js" %>
<%= highlight "4~7" %>

////

////

<% note do %>

### More About Data Contexts

////

////

~~~html
{{#each widgets}}
  {{> widgetItem}}
{{/each}}
~~~

////

~~~html
{{#with myWidget}}
  {{> widgetPage}}
{{/with}}
~~~

////

~~~js
{{> widgetPage myWidget}}
~~~

<% end %>

### Using a Dynamic Named Route Helper

////

////

~~~html
<template name="postItem">
  <div class="post">
    <div class="post-content">
      <h3><a href="{{url}}">{{title}}</a><span>{{domain}}</span></h3>
    </div>
    <a href="{{pathFor 'postPage'}}" class="discuss btn">Discuss</a>
  </div>
</template>
~~~
<%= caption "client/views/posts/post_item.html"%>
<%= highlight "6" %>
<%= commit "5-3", "Routing to a single post page." %>

////

////

////

////

////

<%= screenshot "5-2", "A single post page." %>

<% note do %>

### HTML5 pushState

////

////

////

<% end %>
