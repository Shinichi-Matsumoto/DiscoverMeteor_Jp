---
title: Collections
slug: collections
date: 0004/01/01
number: 4
contents: Meteorの基本的な特徴であるリアルタイムコレクションについて学びます。|どのようにMeteorのデータが同期するのか理解します。|コレクションをテンプレートと一体化させる。（？？？）|ここまでで作った試作品をリアルタイムで動くアプリにします！
paragraphs: 72
---

１章では、クライアントとサーバー間のデータを自動同期させるMeteorの特徴についてお話しました。

この章では、これがどのように動いているのかもう少し詳しく見ていき、データの自動同期を実現させる鍵であるMeteorコレクションについて見ていきます。

私たちはソーシャルニュースアプリを作っているので、最初にやりたいことは投稿されたリンクの一覧表を作ることです。
投稿されたリンクのことは"post"と呼ぶことにしましょう。（？？？）

当然ながら、投稿をどこかに保存（？？？）しなければなりません。
MeteorはMongoDBとセットになっています。（？？？）
MongoDBはサーバー上で動き、永続的データを保存します。（？？？）

ユーザーのブラウザがどのようなページを開いているのか、ユーザーが現在どんなを打ち込んでいるのかコメントについて状態
（？？？）

このデータはMeteorのコレクションの中に保存されています。

コレクションは　特別なデータ構造です。　　　 MongoDB内に　（？？？？？？）
パブリケーションとサブスクリプションを使った　　　同期しているリアルタイムデータ　　　　つながったユーザーのブラウザから
どうなるのか見て行きましょう。

////　　私たちは投稿データを永続的にしてユーザー間と共有したいので、投稿データを格納するPostsコレクションを作るところから始めます。
まだ　アプリのrootで（？？？）　　collections/フォルダーを作っていないなら、　　posts.jsファイルを　その中に入れます。
そして次のように書き込みます。

~~~js
Posts = new Meteor.Collection('posts');
~~~
<%= caption "collections/posts.js" %>

<%= commit "4-1", "postsコレクションを加える" %>

 client/でもserver/でもないフォルダのコードは、クライアントとサーバーの両方で動きます。
そのため、 Postsコレクションはクライアントとサーバーで動きます。
しかし、コレクションはクライアントとサーバーで全く違うことを行います。

<% note do %>

### Varを使うか使わない？　（？？？）

Meteorでは、　varというキーワードは現在のファイルで（？？？）オブジェクトのスコープを限定します。
ここで私たちはアプリ全体で使えるPostsコレクションを作りたいので、varという用語を使っていないというわけです。

<% end %>

サーバーでは、　コレクションは　MongoDBと通信して どんな変化でも読み込んで書き込む役目を果たします。（？？？）
この意味で　通常のデータベースライブラリと比較できます。（？？？）
しかし、クライアントにおいて　コレクションは　正確なコピー　（？？？）
クライアントサイドのコレクションは 絶えず　ユーザーが気づくことなく（？？？）　　 リアルタイムで最新情報を

<% note do %>

### Console vs Console vs Console

この章では、ブラウザーのコンソールを使っていきます。
ターミナルやMongoDBのシェルとは違います。（？？？）
ここでは、そのあたりについてざっくりと解説していきます。（？？？）

#### ターミナル

<%= screenshot "terminal", "The Terminal" %>

- オペレーティングシステムから呼び出される。
- サーバーサイドのconsole.log()は、ここに出力されます。
- プロンプト：$
- 別名：Shell、Bash

#### ブラウザーコンソール

<%= screenshot "browser-console", "The Browser Console" %>

- ブラウザーでJavaScriptのコードを実行する。
- クライアントサイドのconsole.log()をここに出力する。
- プロンプト： ❯
- 別名：JavaScript Console、DevTools Console

#### Mongoシェル

<%= screenshot "mongo-shell", "The Mongo Shell" %>

- meteor mongo か mrt mongo を使って、ターミナルから呼び出される。
- 自作アプリのデータベースに直接アクセスできるようになる。（？？？）
- プロンプト：>
- 別名：Mongoコンソール

ここで留意すべきことは、$・❯・>といったプロンプト文字をコマンドで入力しなくて良いということです。
プロンプトより先の文字は、それより先に行ってたコマンドが出力したものと見なすことができます（？？？）

<% end %>

###サーバーサイドのコレクション

サーバーでは、　コレクションは　MongoDB （？？？） APIとしての役割を果たします。
サーバーサイドのコードで　Posts.insert() や Posts.update() のようなMongoコマンドを書くことができます。
（？？？）　MongoDB内に格納されているpostsコレクションが変化します

MongoDB内を見るために、２つ目のターミナルウィンドウをを開きます。（１つ目のターミナルではまだmeteorが動いています。）
そうしたら、アプリのディレクトリへ行きましょう。
　 Mongoコマンドを入力する　Mongoシェルを起動
では、新しい投稿を書き込みましょう。　 
　 

~~~bash
> db.posts.insert({title: "A new post"});

> db.posts.find();
{ "_id": ObjectId(".."), "title" : "A new post"};
~~~
<%= caption "The Mongo Shell" %>

<% note do %>

### Mongo on Meteor.com　（？？？）

meteor.comにアプリをホスティングする際は、meteor mongo myAppと入力して（？？？）デプロイされたアプリのMongoシェルにアクセスできることに

（？？？）、meteor logs myAppと入力することで、アプリのログを見ることができます。

<% end %>

MongoDBの構文は、JavaScriptインターフェースを使っているため、親しみやすくなっています。
 私たちは　Mongoシェルで　データ操作をしませんが　（？？？）、　そこに（？？？）何があるのか確認するために　時々のぞき見するかもしれません。

### クライアントサイドのコレクション

コレクションはクライアントサイドでは、より面白くなってきます。
クライアントでPosts = new Meteor.Collection('posts');と宣言すると（？？？）、作っている、 Mongoコレクションの　ブラウザーのキャッシュ（？？？）　ローカルなのです。
クライアントサイドのコレクションは「キャッシュ」となります。
キャッシュはデータの一部分を保持して、データへのアクセスを高速化させます。

この点を理解することは大事なことです。というのは、Meteorがどのように動いているのかという基本だからです。
一般的に、クライアントサイドのコレクションはMongoコレクションに保存されている全てのドキュメントから構成されます。
（結局のところ、私たちは全てのデータベースをクライアントに送りたいわけではありません。）

（？？？）、ブラウザーの記憶装置に保存されているドキュメントにアクセスするというのは、基本的には瞬間的であるということです。
つまり、データを取ってくるためにクライアントでPosts.find()を呼び出す際、データは最初から組み込まれているのでサーバーやデータベースへのアクセスは速いのです。

<% note do %>

### Introducing MiniMongo

Meteorのクライアントサイドでの実装は MiniMongoと呼ばれます。
まだ完全な実装ではないので、（？？？）時々MiniMongoで動かないMongoDBの特徴に遭遇するかもしれません。
とはいえ、本書でカバーする全ての特徴は　MongoDBとMiniMongo 同じように動きます。（？？？）
 
<% end %>

### クライアントとサーバーの通信

ここで重要な点は、どのようにクライアントサイドのコレクションが同じ名前のサーバーサイドのコレクションと同期するのかということです。　　
（この場合では、'posts'）

この点を詳細に説明するよりも、実際に何が起こるのか見て行きましょう。

まず２つのブラウザーウィンドウを開いて、両方でブラウザーコンソールにアクセスしましょう。
それから、コマンドライン上でMongoシェルを開きます。
現段階では、先ほど作った１つのドキュメントがあります。　　（？？？）

~~~bash
> db.posts.find();
{title: "A new post", _id: ObjectId("..")};
~~~
<%= caption "The Mongo Shell" %>

~~~js
❯ Posts.findOne();
{title: "A new post", _id: LocalCollection._ObjectID};
~~~
<%= caption "First browser console" %>

新しい投稿を作りましょう。ブラウザーウィンドウの一つで、insertコマンドを実行します。

~~~js
❯ Posts.find().count();
1
❯ Posts.insert({title: "A second post"});
'xxx'
❯ Posts.find().count();
2
~~~
<%= caption "First browser console" %>

当然のように、投稿はローカルのコレクションに作られました。MongoDBをチェックしましょう。

~~~bash
❯ db.posts.find();
{title: "A new post", _id: ObjectId("..")};
{title: "A second post", _id: 'yyy'};
~~~
<%= caption "The Mongo Shell" %>

ご覧のように、投稿　　全てのMongoDBをさかのぼります（？？？）
（？？？）
（？？？）

////

~~~js
❯ Posts.find().count();
2
~~~
<%= caption "Second browser console" %>

２つ目のブラウザーウィンドウを上に持ってきて（？？？）、ブラウザーコンソールに次のように入力します。

その投稿もそこにあります！（？？？）
更新もせず、２つ目のブラウザーと情報をやりとりもしていないのにもせず、更新情報を転送するコードも書いていません。（？？？）
魔法のように一瞬にして、このことが起こります。（？？？）
この点は、章を進めるにつれ理解できるようになります。

実際に何が起こったのか　サーバーサイドのコレクションが　新しい投稿のあった　クライアントのコレクションを　　知らせた （？？？）

### Keeping it Real-time

ブラウザーコンソールで　コレクションの中には　１つの（？？？）　がありますが、
ここでやりたいことは、スクリーン上でデータを表示したり、データを変更することです。
そのようにするため、　静的データを表示している単なるWebページのアプリ（？？？）を、
　動的にデータを変更する（？？？）リアルタイムWebアプリにしていきます。（？？？）

どうやるのか、見ていきましょう。

### Populating the Database

最初にやることは、　データベースにデータを入れることです。（？？？）
　　
最初に（？？？）　サーバーを立ち上げる時に　構造化データにPostsコレクションを入れる 固定データ を　処理します。（？？？）

まず、データベースの中が何もないようにしましょう。
meteor resetを使うことで、　データベースを削除してプロジェクトをリセットします。
当然のことながら、あなたが実際のプロジェクトに取り組み始めたら、このコマンドに対して十分注意が必要です。

 ctrl-cを押してMeteorのサーバーを止めてから、コマンドラインを走らせます。（？？？）

~~~bash
$ meteor reset
~~~

リセットコマンドはMongoDBを完全に空にします。
これはデータベースが一貫性のない状態に陥る可能性が高い開発では便利なコマンドです。（？？？）

データベースが空になりましたので、次のコードを書き込みましょう。
そうすることで、サーバーが起動して空のPostsコレクションを見つけたときは３つの投稿読み込みます。（？？？）

~~~js
if (Posts.find().count() === 0) {
  Posts.insert({
    title: 'Introducing Telescope',
    author: 'Sacha Greif',
    url: 'http://sachagreif.com/introducing-telescope/'
  });
  
  Posts.insert({
    title: 'Meteor',
    author: 'Tom Coleman',
    url: 'http://meteor.com'
  });
  
  Posts.insert({
    title: 'The Meteor Book',
    author: 'Tom Coleman',
    url: 'http://themeteorbook.com'
  });
}
~~~
<%= caption "server/fixtures.js" %>

<%= commit "4-2", "Added data to the posts collection." %>

私たちは　server/ディレクトリにこのファイルを入れたので、ユーザーのブラウザーで読み込まれることはありません。
このコードは、サーバーが起動するとすぐに実行され、 insertで　データベースに　Postsコレクション内に３つの投稿を加えます（？？？）　　 　データベースを呼び出す
今のところ、データセキュリティの対策をしていないので、サーバー上のファイル内でこれを行うのと、ブラウザーで行うのとで実質的な違いはありません。（？？？）

 再びmeteorでサーバーを起動すると、この３つの投稿はデータベースに読み込まれます。（？？？）

### ヘルパーを使ってHTMLにデータをつなげる

ブラウザーコンソールを開いたら、MiniMongo内に（？？？）読み込まれた３つの投稿が（？？？）

~~~js
❯ Posts.find().fetch();
~~~
<%= caption "Browser console" %>

この投稿をレンダリングしたHTMLにするため、テンプレートヘルパーを使います。
３章では、どのようにMeteorがデータコンテキストをシンプルなデータ構造のHTML表示を作り出すSpacebarsテンプレートと結合するのかを見てきました。（？？？）
　私たちは（？？？）まさに同じような方法でコレクションデータを結びつけることができます。
 私たちは（？？？）静的なJavaScriptのpostsDataオブジェクトを動的なコレクションに置き換えます。

そういえば、現在のところ　postsDataコードを削除　（？？？）
現在のposts_list.jsは、このようになっています。

~~~js
Template.postsList.helpers({
  posts: function() {
    return Posts.find();
  }
});
~~~
<%= caption "client/views/posts/posts_list.js" %>
<%= highlight "2~4" %>

<%= commit "4-3", "Wired collection into `postsList` template." %>

<% note do %>

### Find と Fetch

Meteor　find()は、リアクティブデータ・ソースの（？？？）カーソルを返します。
その（？？？）中身の記録を取り出したい時は、　 fetch()を使います。　カーソルでは、（？？？）を配列に変えます。

アプリ内では、Meteor　　配列に変換しないで（？？？）　カーソルを繰り返し処理することもできます。　
そのような理由で、実際のMeteorコードでfetch()を見る機会はそれほど多くないでしょう。
（また、そのような理由から上記の例でfetch()を使いませんでした。）
　
<% end %>

ここでは、静的配列の投稿リストを変数から呼び出すのではなく、カーソルをpostsヘルパーに返しています。
しかし、何がこれをしているのでしょうか。（？？？）
ブラウザーに戻って、　（？？？）

<%= screenshot "4-3", "Using live data（？？？）　" %>

{{#each}}ヘルパーが　 全てのPostsを繰り返し処理して、スクリーン上で表示していることがはっきりとわかります。
サーバーサイド　コレクション　MongoDBから投稿を呼び出して、  　クライアントサイド　コレクションに引き渡します。
それから、 Spacebarsヘルパーがそれらを（？？？）テンプレートに引渡ます。

（？？？）、さらにもう一歩踏み込みます。；コンソールから投稿を加えましょう。

~~~js
❯ Posts.insert({
  title: 'Meteor Docs', 
  author: 'Tom Coleman', 
  url: 'http://docs.meteor.com'
});
~~~
<%= caption "Browser console" %>

ブラウザーを見てみると、このようになっているはずです。

<%= screenshot "4-4", "コンソールから投稿を加える" %>

たった今、あなたは初めて実行中の反応性（？？？）を見ました（？？？）
Posts.find()を繰り返し処理する Spacebars について話していた時、カーソルでの変化を観察する方法を知っていました（？？？）
 スクリーン上で正しいデータを表示するために、とてもシンプルな方法で　　 HTMLを（？？？）つなぎあわせます。

<% note do %>

### Inspecting DOM Changes

////（？？？）

////（？？？）

<% end %>

### コレクションをつなげる: Publications と Subscriptions

今のところ、実際のアプリには向いていないautopublishパッケージが有効となっていました。（？？？）
名前が意味しているように、このパッケージは単純に　それぞれつながったクライアントと　コレクションが共有されます（？？？）
私たちはこうしたことをしたくないので、autopublishを停止させましょう。

新しいターミナルを開いて、次のように打ち込みます（？？？）

~~~bash
$ meteor remove autopublish
~~~

これはすぐに有効化されます。今ブラウザーを見ると、全ての投稿が消えているのがわかるはずです！（？？？）

　クライアントサイドの投稿は（？？？）　　データベースにある投稿を　反映した　（？？？）　　　autopublishに依存していたからです。

最終的には、　ユーザーが見る必要のある投稿だけに変換する必要があります。
（ページネーションのようなものを考慮して）　（？？？）
しかし、今はPostsが全体にpublishされるように（？？？）設定します。

そうするために、全ての投稿を参照するカーソルを返すpublish()関数を作ります。

~~~js
Meteor.publish('posts', function() {
  return Posts.find();
});
~~~
<%= caption "server/publications.js" %>

クライアントでは、publicationにsubscribe（？？？）する必要があります。
main.jsに次のようなコードを加えましょう。

~~~js
Meteor.subscribe('posts');
~~~
<%= caption "client/main.js" %>

<%= commit "4-4", "`autopublish`を削除して、基本的なpublicationをセットアップする。" %>

再びブラウザーをチェックすると、投稿が元に戻っています。ふぅ！

### 結論

　何を達成した　（？？？）　？
　まだユーザーインターフェースはありませんが、　私たちが行ったことは関数型のWebアプリケーションです。
　私たちはこのアプリケーションをインターネットにデプロイすることができます。
　また、ブラウザーコンソールを使って新しい投稿をして　　　世界中のユーザーのブラウザーで見ることができます。
　
