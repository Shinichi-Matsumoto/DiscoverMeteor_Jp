---
title: Collections
slug: collections
date: 0004/01/01
number: 4
contents: Meteorの基本的な特徴であるリアルタイムコレクションについて学びます。|どのようにMeteorのデータが同期するのか理解します。|コレクションをテンプレートと一体化させる。（？？？）|ここまでで作った試作品をリアルタイムで動くアプリにします！
paragraphs: 72
---

In chapter one, we spoke about the core feature of Meteor, 
the automatic synchronisation of data between client and server.
　１章では、クライアントとサーバー間のデータを自動同期させる Meteor の特徴についてお話しました。

In this chapter, we'll take a closer look at how that works, 
and observe the operation of the key piece of technology that enables this, the Meteor Collection.
　この章では、これがどのように動いているのかもう少し詳しく見ていき、
　データの自動同期を実現させる上で鍵となる Meteor コレクションについて見ていきます。

We are building a social news app, 
so the first thing we want to do is make a list of links that people have posted. 
We'll call each of these items a "post."
　私たちはソーシャルニュースアプリを作っているので、最初にやりたいことは投稿されたリンクの一覧表を作ることです。
　投稿されたリンクのことは "post" と呼ぶことにしましょう。（？？？）

Naturally, we need to store these posts somewhere.
Meteor comes bundled with a Mongo database which runs on your server 
and is your persistent data store.
　当然ながら、投稿をどこかに格納しなければなりません。
　Meteor は MongoDB とセットになっています。（？？？）
　MongoDB はサーバー上で動き、永続的にデータを保存します。（？？？）

So, although a user's browser may contain some kind of state 
(for instance which page they are on, or the comment they are currently typing), 
the server, and specifically Mongo, contains the permanent, 
canonical data source.
 By canonical, we mean that it is the same for all users:
each user might be on a different page, 
but the master list of posts is the same for all.
　ユーザーのブラウザがどのようなページを開いているのか、
　現在コメントを書いているかといったさまざまな状態がありますが、
　特に Mongo のサーバーは永続的で標準的なデータソースを保存します。
（？？？）
　
This data is stored in Meteor in the Collection. 
A collection is a special data structure that, 
through publications and subscriptions, 
takes care of synchronising real-time data to and from each connected user's browser and into the Mongo database.
Let's see how.
　データはMeteorのコレクションの中に保存されます。
　コレクションは特別なデータ構造で、　　　
　パブリケーションとサブスクリプションを使って同期しているリアルタイムデータつながったユーザーのブラウザから    MongoDB内に　（？？？？？？）
どうなるのか見て行きましょう。

We want our posts to be permanent and shared between users, 
so we'll start by creating a collection called Posts to store them in. 
If you haven't done so already create a collections/ folder 
at the root of your app, and then a posts.js file inside it. 
Then add:
　　私たちは投稿データを永続化してユーザー間と共有したいので、投稿データを格納するPostsコレクションを作るところから始めます。
まだ　アプリのrootで（？？？）　　collections/ フォルダーに posts.js ファイルを入れます。
そして次のように書き込みます。

~~~js
Posts = new Meteor.Collection('posts');
~~~
<%= caption "collections/posts.js" %>

<%= commit "4-1", "postsコレクションを加える" %>

Code inside folders that are not client/ or server/ will run in both contexts. 
So the Posts collection is available to both client and server. 
However, what the collection does in each environment is very different.
 client/ でも server/ でもないフォルダのコードは、クライアントとサーバーの両方で動きます。
　そのため、 Postsコレクションはクライアントとサーバーで動きます。
　しかし、コレクションはクライアントとサーバーで行うことが大きく異なります。

<% note do %>

### Varを使うか使わないか？　（？？？）

In Meteor, the var keyword limits the scope of an object to the current file. 
Here, we want to make the Posts collection available to our whole app, 
which is why we're not using the var keyword.
　Meteorでは、var というキーワードは現在のファイルで（？？？）オブジェクトのスコープを限定します。
　ここで私たちはアプリ全体で使える Posts コレクションを作りたいので、var という用　語を使っていないというわけです。

<% end %>

On the server, the collection has the job of talking to the Mongo database, 
and reading and writing any changes. 
In this sense, it can be compared to a standard database library. 
On the client however, 
the collection is a secure copy of a subset of the real, canonical collection. 
The client-side collection is constantly 
and (mostly) transparently kept up to date with that subset in real-time.
 サーバーでのコレクションは MongoDB と通信して、あらゆる変化を読み込んで書き込む役目を果たします。（？？？）
　この意味で通常のデータベースライブラリと比較できます。（？？？）
　一方で、クライアントでのコレクションは　（  subset of the real？）の正確なコピーで、標準的なコレクションです。
　クライアントサイドのコレクションはユーザーが意識することなく 絶えずリアルタイムで最新情報を処理します。

<% note do %>

### Console vs Console vs Console

In this chapter, we'll start making use of the browser console, 
which is not to be confused with the terminal or the Mongo shell. 
Here's a quick primer on each of them.
　この章では、ブラウザーのコンソールを使っていきます。
　これはターミナルや Mongo シェルとは違います。
　ここでは、そのあたりについてざっくりと解説していきます。（？？？）

#### ターミナル

<%= screenshot "terminal", "The Terminal" %>

Called from your operating system.
Server-side console.log() calls output here.
Prompt: $.
Also known as: Shell, Bash
　- オペレーティングシステムから呼び出される。
　- サーバーサイドのconsole.log()は、ここに出力される。
　- プロンプト：$
　- 別名：Shell、Bash

#### ブラウザーコンソール

<%= screenshot "browser-console", "The Browser Console" %>

Called from inside the browser, executes JavaScript code.
Client-side console.log() calls output here.
Prompt: ❯.
Also known as: JavaScript Console, DevTools Console
　- ブラウザーで JavaScript のコードを実行する。
　- クライアントサイドの console.log() をここに出力する。
　- プロンプト： ❯
　- 別名：JavaScript Console、DevTools Console

#### Mongoシェル

<%= screenshot "mongo-shell", "The Mongo Shell" %>

Called from the Terminal with meteor mongo.
Gives you direct access to your app's database.
Prompt: >.
Also know as: Mongo Console
　- meteor mongo か mrt mongo を使って、ターミナルから呼び出される。
　- 自作アプリのデータベースに直接アクセスできるようになる。（？？？）
　- プロンプト：>
　- 別名：Mongoコンソール

Note that in each case, 
you're not supposed to type the prompt character ($, ❯, or >) 
as part of the command. 
And you can assume that any line not beginning with the prompt is the output of the preceding command.
　ここで留意すべきことは、$・❯・>といったプロンプト文字をコマンドで入力しなくて良いということです。
　プロンプトより先の文字で始まっていないものは、それより先に行ってたコマンドが出力したものと見なすことができます。

<% end %>

###サーバーサイドのコレクション

On the server, the collection acts as an API into your Mongo database. 
In your server-side code, 
this allows you to write Mongo commands like Posts.insert() or Posts.update(), and they will make changes to the posts collection stored inside Mongo.
　サーバーでのコレクションは MongoDB の API のような役割を果たします。
　サーバーサイドのコードで　Posts.insert() や Posts.update() のようなMongoコマンドを書くことができます。
　すると、MongoDB 内に格納されている posts コレクションは変化します。

To look inside the Mongo database,
 open up a second terminal window (while meteor is still running in your first), and go to your app's directory. 
Then, run the command meteor mongo to initiate a Mongo shell,
 into which you can type standard Mongo commands 
(and as usual, you can quit it with the ctrl+c keyboard shortcut). 
For example, let's insert a new post:
　MongoDB 内を見るために、２つ目のターミナルウィンドウをを開きます。（１つ目のターミナルではまだ meteor が動いている状態です。）
　そうしたら、アプリのディレクトリへ行きましょう。
　そして、Mongo シェルを起動するために meteor mongo コマンドを実行します。
　Mongo シェルでは、通常の Mongo コマンドを入力することができます。
　（また、いつものように ctrl+c で停止することができます。）
　例として、新しい投稿を挿入しましょう。

~~~bash
> db.posts.insert({title: "A new post"});

> db.posts.find();
{ "_id": ObjectId(".."), "title" : "A new post"};
~~~
<%= caption "The Mongo Shell" %>

<% note do %>

### Mongo on Meteor.com　（？？？）

Note that when hosting your app on *.meteor.com, you can also access your deployed app's Mongo shell with meteor mongo myApp.
　meteor.com にアプリをホスティングする際は、meteor mongo myAppと入力することでデプロイされたアプリのMongoシェルにアクセスすることができます。

And while we're at it, you can also get your app's logs by typing meteor logs myApp.
　さらに、その状態で meteor logs myApp と入力すること、アプリのログを見ることができます。

<% end %>

Mongo's syntax is familiar, as it uses a JavaScript interface. 
We won't be doing any further data manipulation in the Mongo shell, 
but we might take a peek inside from time to time 
just to make sure what's in there.
　MongoDB の構文は、JavaScript インターフェースを使っているため、親しみやすくなっています。
　私たちはこれ以上 Mongoシェルでデータ操作をしませんが、　（there=MongoDB内？）に何があるのか確認するために時々のぞき見をするかもしれません。

### クライアントサイドのコレクション

Collections get more interesting client-side. 
When you declare Posts = new Meteor.Collection('posts'); on the client, 
what you are creating is a local, in-browser cache of the real Mongo collection. When we talk about a client-side collection being a "cache", 
we mean it in the sense that it contains a subset of your data, 
and offers very quick access to this data.
　コレクションはクライアントサイドでは、より面白くなってきます。
　クライアントでPosts = new Meteor.Collection('posts');と宣言すると、作っている、 Mongoコレクションの　ブラウザーのキャッシュ（？？？）
　クライアントサイドのコレクションで「キャッシュ」という場合、データの一部分を保持して、データへのアクセスを高速化させるキャッシュのことを意味しています。

It's important to understand this point 
as it's fundamental to the way Meteor works. 
In general, 
a client side collection consists of a subset of all the documents stored 
in the Mongo collection 
(after all, we generally don't want to send our whole database to the client).
　この点を理解することは大事なことです。
　というのは、これが Meteor が動作する方法の基本だからです。
　一般的に、クライアントサイドのコレクションは Mongo コレクションに格納されているすべてのドキュメントの一部分から構成されます。
　（結局のところ、私たちはすべてのデータベースをクライアントに送りたいわけではありません。）

Secondly, those documents are stored in browser memory, 
which means that accessing them is basically instantaneous. 
So there are no slow trips to the server or the database to fetch the data 
when you call Posts.find() on the client, as the data is already pre-loaded.
　次に、こうしたドキュメントはブラウザーのメモリに保存されているので、このドキュメントには基本的に瞬間的にアクセスするということを意味しています。
　つまり、データを取ってくるためにクライアントで Posts.find() を呼び出す際、データは最初から組み込まれているのでサーバーやデータベースへのアクセスは速いのです。

<% note do %>

### Introducing MiniMongo

Meteor's client-side Mongo implementation is called MiniMongo. 
It's not a perfect implementation yet, 
and you may encounter occasional Mongo features that don't work in　MiniMongo. 
Nevertheless, all the features we cover in this book work similarly 
in both Mongo and MiniMongo.
　Meteor のクライアントサイドでの実装は MiniMongo と呼ばれます。
　まだ完全な実装ではないので（？？？）、通常の MongoDB の機能が MiniMongo で動かないことがあるかもしれません。
　とはいえ、本書でカバーしているすべての機能は MongoDB と MiniMongo で同じように動きます。
 
<% end %>

### クライアントとサーバーの通信

The key piece of all this is how the client-side collection synchronizes its data with the server-side collection of the same name ('posts' in our case).
　ここで重要な点は、どのようにクライアントサイドのコレクションが同じ名前のサーバーサイドのコレクションと同期するのかということです。（この場合では、'posts'）

Rather than explaining this in detail, let's just watch what happens.
　この点を詳細に説明するよりも、実際に何が起こるのか見て行きましょう。

Start by opening up two browser windows, 
and accessing the browser console in each one. 
Then, open up the Mongo shell on the command line. 
At this point, we should see the single document 
we created earlier in all three contexts.
　まず２つのブラウザーウィンドウを開いて、両方でブラウザーコンソールにアクセスしましょう。
　それから、コマンドラインで Mongo シェルを開きます。
　現段階では、先ほど作った１つのドキュメントがあります。　　（？？？）

~~~bash
> db.posts.find();
{title: "A new post", _id: ObjectId("..")};
~~~
<%= caption "The Mongo Shell" %>

~~~js
❯ Posts.findOne();
{title: "A new post", _id: LocalCollection._ObjectID};
~~~
<%= caption "First browser console" %>

Let's create a new post. In one of the browser windows, 
run an insert command:
　新しい投稿を作りましょう。
　ブラウザーウィンドウの一つで、insert コマンドを実行します。

~~~js
❯ Posts.find().count();
1
❯ Posts.insert({title: "A second post"});
'xxx'
❯ Posts.find().count();
2
~~~
<%= caption "First browser console" %>

Unsurprisingly, the post made it into the local collection. 
Now let's check Mongo:
当然のように、投稿はローカルのコレクションに作られました。
Mongo をチェックしましょう。

~~~bash
❯ db.posts.find();
{title: "A new post", _id: ObjectId("..")};
{title: "A second post", _id: 'yyy'};
~~~
<%= caption "The Mongo Shell" %>

As you can see, the post made it all the way back to the Mongo database, without us writing a single line of code to hook our client up to the server 
(well, strictly speaking, we did write a single line of code: 
new Meteor.Collection('posts')). But that's not all!
ご覧のように、この投稿はクライアントとサーバーをフックするための一行もコードを書くことなく、すべてのMongoDBをさかのぼります。（？？？）
（厳密に言うと、私たちは new Meteor.Collection('posts') という一行のコードを書きました。）
しかし、話はここで終わりません。

Bring up the second browser window and enter this in the browser console:
　２つのブラウザーウィンドウを立ち上げて、ブラウザーコンソールに次のように入力します：

~~~js
❯ Posts.find().count();
2
~~~
<%= caption "Second browser console" %>

The post is there too! 
Even though we never refreshed or even interacted with the second browser, 
and we certainly didn't write any code to push updates out. 
It all happened magically -- and instantly too, 
although this will become more obvious later.
　その投稿もここにあります！（？？？）
　私たちは更新もせず、
　２つ目のブラウザーと情報をやりとりもしていないのにもせず、
　更新情報を転送するコードも書いていません。（？？？）
　魔法のように一瞬にして、このことが起こります。（？？？）
　この点は、章を進めるにつれ理解できるようになります。

What happened is that our server-side collection was informed 
by a client collection of a new post, 
and took on the task of distributing that post into 
the Mongo database and back out to all the other connected post collections.
実際に何が起こったのか　サーバーサイドのコレクションが　新しい投稿のあった　クライアントのコレクションを　　知らせた （？？？）

Fetching posts on the browser console isn't that useful. 
We will learn how to wire this data into our templates, 
and in the process turn our simple HTML prototype 
into a functioning realtime web application.


### Keeping it Real-time

ブラウザーコンソールで　コレクションの中には　１つの（？？？）　がありますが、
ここでやりたいことは、スクリーン上でデータを表示したり、データを変更することです。
そのようにするため、　静的データを表示している単なるWebページのアプリ（？？？）を、
　動的にデータを変更する（？？？）リアルタイムWebアプリにしていきます。（？？？）

どうやるのか、見ていきましょう。

### Populating the Database

最初にやることは、　データベースにデータを入れることです。（？？？）
　　
最初に（？？？）　サーバーを立ち上げる時に　構造化データにPostsコレクションを入れる 固定データ を　処理します。（？？？）

まず、データベースの中が何もないようにしましょう。
meteor resetを使うことで、　データベースを削除してプロジェクトをリセットします。
当然のことながら、あなたが実際のプロジェクトに取り組み始めたら、このコマンドに対して十分注意が必要です。

 ctrl-cを押してMeteorのサーバーを止めてから、コマンドラインを走らせます。（？？？）

~~~bash
$ meteor reset
~~~

リセットコマンドはMongoDBを完全に空にします。
これはデータベースが一貫性のない状態に陥る可能性が高い開発では便利なコマンドです。（？？？）

データベースが空になりましたので、次のコードを書き込みましょう。
そうすることで、サーバーが起動して空のPostsコレクションを見つけたときは３つの投稿読み込みます。（？？？）

~~~js
if (Posts.find().count() === 0) {
  Posts.insert({
    title: 'Introducing Telescope',
    author: 'Sacha Greif',
    url: 'http://sachagreif.com/introducing-telescope/'
  });
  
  Posts.insert({
    title: 'Meteor',
    author: 'Tom Coleman',
    url: 'http://meteor.com'
  });
  
  Posts.insert({
    title: 'The Meteor Book',
    author: 'Tom Coleman',
    url: 'http://themeteorbook.com'
  });
}
~~~
<%= caption "server/fixtures.js" %>

<%= commit "4-2", "Added data to the posts collection." %>

私たちは　server/ディレクトリにこのファイルを入れたので、ユーザーのブラウザーで読み込まれることはありません。
このコードは、サーバーが起動するとすぐに実行され、 insertで　データベースに　Postsコレクション内に３つの投稿を加えます（？？？）　　 　データベースを呼び出す
今のところ、データセキュリティの対策をしていないので、サーバー上のファイル内でこれを行うのと、ブラウザーで行うのとで実質的な違いはありません。（？？？）

 再びmeteorでサーバーを起動すると、この３つの投稿はデータベースに読み込まれます。（？？？）

### ヘルパーを使ってHTMLにデータをつなげる

ブラウザーコンソールを開いたら、MiniMongo内に（？？？）読み込まれた３つの投稿が（？？？）

~~~js
❯ Posts.find().fetch();
~~~
<%= caption "Browser console" %>

この投稿をレンダリングしたHTMLにするため、テンプレートヘルパーを使います。
３章では、どのようにMeteorがデータコンテキストをシンプルなデータ構造のHTML表示を作り出すSpacebarsテンプレートと結合するのかを見てきました。（？？？）
　私たちは（？？？）まさに同じような方法でコレクションデータを結びつけることができます。
 私たちは（？？？）静的なJavaScriptのpostsDataオブジェクトを動的なコレクションに置き換えます。

そういえば、現在のところ　postsDataコードを削除　（？？？）
現在のposts_list.jsは、このようになっています。

~~~js
Template.postsList.helpers({
  posts: function() {
    return Posts.find();
  }
});
~~~
<%= caption "client/views/posts/posts_list.js" %>
<%= highlight "2~4" %>

<%= commit "4-3", "Wired collection into `postsList` template." %>

<% note do %>

### Find と Fetch

Meteor　find()は、リアクティブデータ・ソースの（？？？）カーソルを返します。
その（？？？）中身の記録を取り出したい時は、　 fetch()を使います。　カーソルでは、（？？？）を配列に変えます。

アプリ内では、Meteor　　配列に変換しないで（？？？）　カーソルを繰り返し処理することもできます。　
そのような理由で、実際のMeteorコードでfetch()を見る機会はそれほど多くないでしょう。
（また、そのような理由から上記の例でfetch()を使いませんでした。）
　
<% end %>

ここでは、静的配列の投稿リストを変数から呼び出すのではなく、カーソルをpostsヘルパーに返しています。
しかし、何がこれをしているのでしょうか。（？？？）
ブラウザーに戻って、　（？？？）

<%= screenshot "4-3", "Using live data（？？？）　" %>

{{#each}}ヘルパーが　 全てのPostsを繰り返し処理して、スクリーン上で表示していることがはっきりとわかります。
サーバーサイド　コレクション　MongoDBから投稿を呼び出して、  　クライアントサイド　コレクションに引き渡します。
それから、 Spacebarsヘルパーがそれらを（？？？）テンプレートに引渡ます。

（？？？）、さらにもう一歩踏み込みます。；コンソールから投稿を加えましょう。

~~~js
❯ Posts.insert({
  title: 'Meteor Docs', 
  author: 'Tom Coleman', 
  url: 'http://docs.meteor.com'
});
~~~
<%= caption "Browser console" %>

ブラウザーを見てみると、このようになっているはずです。

<%= screenshot "4-4", "コンソールから投稿を加える" %>

たった今、あなたは初めて実行中の反応性（？？？）を見ました（？？？）
Posts.find()を繰り返し処理する Spacebars について話していた時、カーソルでの変化を観察する方法を知っていました（？？？）
 スクリーン上で正しいデータを表示するために、とてもシンプルな方法で　　 HTMLを（？？？）つなぎあわせます。

<% note do %>

### Inspecting DOM Changes

////（？？？）

////（？？？）

<% end %>

### コレクションをつなげる: Publications と Subscriptions

今のところ、実際のアプリには向いていないautopublishパッケージが有効となっていました。（？？？）
名前が意味しているように、このパッケージは単純に　それぞれつながったクライアントと　コレクションが共有されます（？？？）
私たちはこうしたことをしたくないので、autopublishを停止させましょう。

新しいターミナルを開いて、次のように打ち込みます（？？？）

~~~bash
$ meteor remove autopublish
~~~

これはすぐに有効化されます。今ブラウザーを見ると、全ての投稿が消えているのがわかるはずです！（？？？）

　クライアントサイドの投稿は（？？？）　　データベースにある投稿を　反映した　（？？？）　　　autopublishに依存していたからです。

最終的には、　ユーザーが見る必要のある投稿だけに変換する必要があります。
（ページネーションのようなものを考慮して）　（？？？）
しかし、今はPostsが全体にpublishされるように（？？？）設定します。

そうするために、全ての投稿を参照するカーソルを返すpublish()関数を作ります。

~~~js
Meteor.publish('posts', function() {
  return Posts.find();
});
~~~
<%= caption "server/publications.js" %>

クライアントでは、publicationにsubscribe（？？？）する必要があります。
main.jsに次のようなコードを加えましょう。

~~~js
Meteor.subscribe('posts');
~~~
<%= caption "client/main.js" %>

<%= commit "4-4", "`autopublish`を削除して、基本的なpublicationをセットアップする。" %>

再びブラウザーをチェックすると、投稿が元に戻っています。ふぅ！

### 結論

　何を達成した　（？？？）　？
　まだユーザーインターフェースはありませんが、　私たちが行ったことは関数型のWebアプリケーションです。
　私たちはこのアプリケーションをインターネットにデプロイすることができます。
　また、ブラウザーコンソールを使って新しい投稿をして　　　世界中のユーザーのブラウザーで見ることができます。
　
