---
title: Errors
slug: errors
date: 0009/01/01
number: 9
contents: Create a better mechanism for displaying errors and messages.|Learn how to use `Template.rendered` to know when a user has seen an error.|Use a router filter to make sure errors are only seen once.
paragraphs: 31
---

Merely using the browser's standard alert() dialog to warn the user 
when there's problem with their submission
is a bit dissatisfying, and it certainly doesn't make for great UX. 
We can do better.
　（submission？）に問題がある時に、　ユーザーに警告をするために単純に　ブラウザーの標準的な　alert() ダイアログを使うことは
　少々（dissatisfy？）で、素晴らしいUXを（make for？）するわけではありません。
　よりよくできます。（？？？）


Instead, let's build a more versatile error reporting mechanism 
that will do a better job of telling the user what's going on without breaking up their flow.
　その代わりに、（reporting mechanism ？＝報告するメカニズム？）（versatile？）エラーを作りましょう。
　これは（ breaking up their flow？＝フローを壊すことなく？）ユーザーに（what's going on？＝何が起きているか？）
　（tell？＝知らせる？）より良い役割を果たします。

### Introducing Local Collections

We are going to implement a simple system which keeps track of which errors a user has seen and displays the new ones
in a "flash" area of the site.
This UX pattern is useful when we want to inform a user that something has happened without disrupting their workflow too much.
　サイトの（"flash"？）の部分でユーザーがどのエラーを見ているか（keeps track of？）して、
　新しい（ones？＝エラー？）を表示するシンプルなシステムの（implement？）をしていきます。
　このUXパターンはユーザーの（workflow？）を（disrupt？＝邪魔？）せずに、私たちがユーザーに何かが起きていると知らせたいときに、役立ちます。

What we will create is similar to the flash messages often found in Ruby on Rails apps,
but is more subtle in that it's implemented client side and knows when a user has seen a message.
　私たちが作るものは　　Ruby on Railsアプリで　よく見かける　（ flash？）メッセージに似ていますが、
　（more subtle？）です。　（it's implemented client side？）　ユーザーがメッセージを見ている時を　（ know？）

To start off with, we create a collection to store our errors in.
Given that the errors are only relevant to the current session and don't need to be persistent in any way, 
we are going to do something new, and create a local collection.
What this means is that the Errors collection will only exist in the browser, 
and will make no attempt to synchronize with the server.
　（ start off with？）ために、わつぃたちは　エラーを格納するコレクションを作ります。
　エラーは　　現在のセッションに（relevant to？）するだけで、（in any way？）　（ persistent？）する必要がないことを考えると、
　私たちは　何か新しいことをして、　ローカルコレクションを作っていきます。（？？？）
　これが意味することは、Errorsコレクションというものはブラウザ機能にだけ存在して、　
　サーバーと同期することはしないということです。

To achieve this, we simply create the error in a client-only file, with the collection name set to null. 
We create a throwError function that simply inserts an error into our new local collection:
　このようにするために、私たちはコレクションの名前をnullに設定して、（client-only？）ファイルにエラーを作ります。
　私たちは新しいローカルコレクションにエラーを挿入するthrowError関数を作ります。

~~~js
// Local (client-only) collection
Errors = new Meteor.Collection(null);
~~~
<%= caption "client/helpers/errors.js" %>

Now that the collection has been created, we can add a throwError function which we'll call to add errors to it.
We don't need to worry about allow or deny or anything like that, as this is a local collection and will not be saved to the Mongo database.
　これでコレクションが作られたので、私たちは　（it？）にエラーを加えるために呼び出すthrowError関数を入れることができます。
　私たちは　（ allow や deny？）や他のことに心配する必要はありません。というのも、これはローカルコレクションで、MongoDBに保存されていないからです。

~~~js
throwError = function(message) {
  Errors.insert({message: message})
}
~~~
<%= caption "client/helpers/errors.js" %>

The advantage of using a local collection to store the errors is that, like all collections, 
it's reactive -- meaning we can declaratively display the errors in the same way we display any other collection data.
　エラーを格納するためにローカルコレクションを　使うことの利点は、すべてのコレクションに（like？）ですが、
　リアクティブだからです。　つまり、　私たちは　他のコレクションデータを表示するのと同じように　（declaratively？）にエラーを表示することができます。

### Displaying errors

We are going to display the errors at the top of our main layout:
　メインレイアウトの（ top of？）でエラーを表示していきます。

~~~html
<template name="layout">
  <div class="container">
    {{> header}}
    {{> errors}}
    <div id="main" class="row-fluid">
      {{yield}}
    </div>
  </div>
</template>
~~~
<%= caption "client/views/application/layout.html" %>
<%= highlight "7" %>

Let's now create the errors and error templates in errors.html:
　errors.html内に、エラーとエラーテンプレートを作りましょう：

~~~html
<template name="errors">
  <div class="errors row-fluid">
    {{#each errors}}
      {{> error}}
    {{/each}}
  </div>
</template>

<template name="error">
  <div class="alert alert-error">
    <button type="button" class="close" data-dismiss="alert">&times;</button>
    {{message}}
  </div>
</template>
~~~
<%= caption "client/views/includes/errors.html" %>

<% note do %>

### Twin Templates

You'll notice we're putting two templates in a single file. 
Up to now we've tried to adhere to a "one file, one template" convention, 
but as far as Meteor is concerned putting all our templates in a single file works just as well 
(although it would make for a very confusing main.html!).
　私たちは２つのテンプレートを１つのファイルに置いていることにお気づきでしょう。
　今まで私たちは　「１つのファイルに１つのテンプレート」（convention？）を（adhere？）してきましたが、
　Meteorに関する限りでは、１つのファイルにすべてのテンプレートを置くこともできます。

In this case, since both error templates are fairly short, 
we'll make an exception and put them in the same file to make our repo a bit cleaner.
　この場合は、　両方の（ error？）テンプレートはとても少ないので、
　私たちは　リポジトリを少しきれいにしておくために、例外を作って同じファイルにテンプレートを置きました。　

We just need to integrate our template helper, and we'll be good to go!
　私たちは　テンプレートヘルパーをまとめる必要があり、用意ができています。
　

<% end %>



~~~js
Template.errors.helpers({
  errors: function() {
    return Errors.find();
  }
});
~~~
<%= caption "client/views/includes/errors.js" %>

<%= commit "9-1", "Basic error reporting." %>

### Creating errors

We now know how to display errors, but we still need to create some before we'll see anything. 
Errors are most commonly triggered by users entering new content, 
so we'll check for errors in our post creation callback, and display a message for any errors that get raised.
　私たちは　エラーを表示する方法を知っていますが、（anything？）を見る前に　（ some？）を作る必要があります。
　ユーザーが新しい投稿を入れることで、エラーは最も普遍的に　（triggered ？）されるので、
　（ post creation callback？）でエラーをチェックして、　（any errors that get raised？）メッセージを表示します。

In addition, if we get the 302 error (which indicates that a post with the same URL already exists), 
we'll redirect the user to the existing post. 
We obtain the existing post's _id from error.details 
(remember we passed that post's _id as the third details argument of our Error class in chapter 7).
　さらに、302 error（これは　同じURLの投稿がすでに存在していることを示しています。）を（get？）したら、
　すでに存在している投稿にユーザーを　リダイレクトします。
　私たちはerror.details から　すでに存在している投稿の　_idを（obtain？）しています
　（私たちが（as the third details argument of our Error class in chapter 7？）として投稿の_idを渡したことを　思い出しましょう。）

~~~js
Template.postSubmit.events({
  'submit form': function(e) {
    e.preventDefault();
    
    var post = {
      url: $(e.target).find('[name=url]').val(),
      title: $(e.target).find('[name=title]').val(),
      message: $(e.target).find('[name=message]').val()
    }
    
    Meteor.call('post', post, function(error, id) {
      if (error) {
        // display the error to the user
        throwError(error.reason);
        
        if (error.error === 302)
          Router.go('postPage', {_id: error.details})
      } else {
        Router.go('postPage', {_id: id});
      }
    });
  }
});
~~~
<%= caption "client/views/posts/post_submit.js" %>
<%= highlight "12~14, 16~21" %>

<%= commit "9-2", "Actually use the error reporting." %>

Give it a try: try creating a post and entering the URL http://meteor.com. As this URL is already attached to a post in the fixtures, you should see:
試してましょう：投稿を作って、http://meteor.comにURLを入力してみましょう。　このURLがすでに（in the fixtures？）に投稿が（attached）されていたら、 （you should see？）

<%= screenshot "9-1", "Triggering an error" %>

### Clearing Errors


If you click the error's close button at this point, 
you'll see the error disappear, because that close button triggers Twitter Bootstrap's embedded JavaScript.
　（at this point？）でエラーのクローズボタンをクリックすると、エラーが消えます。
　これはクローズボタンが　Twitter Bootstrapの（embedded）された　JavaScript　を（trigger？）するからです。


But while Bootstrap is removing the error <div> from the DOM, 
it's not removing the error object from the Meteor collection. 
So let's add a way to clean up our local collection once an error has done its job.
　しかし、Bootstrapは　DOM（ from？＝で？）エラー<div>を削除しますが、
　Meteorコレクションから　エラーオブジェクトを削除しません。
　（once an error has done its job？＝エラーが役割を果たしたら？）、ローカルコレクションを　きれいにする方法を　（add？）しましょう。


First, we'll modify the throwError function to include a seen property. 
This will be useful later on to keep track of whether an error has been actually seen by the user.
　最初に、私たちは　（seen？）プロパティを（include？）するために　throwErrorエラー関数を修正します。
　これは　エラーが実際にユーザーに見られたのか（ keep track of？）するために、後々役立ちます　

Once that's done, we can code up a simple clearErrors function that clears those "seen" errors:
　これが終わると、私たちは（"seen" ？）エラーをクリアする　clearErrors関数を（ code up ？）できます。

~~~js
// Local (client-only) collection
Errors = new Meteor.Collection(null);

throwError = function(message) {
  Errors.insert({message: message, seen: false})
}

clearErrors = function() {
  Errors.remove({seen: true});
}
~~~
<%= caption "client/helpers/errors.js" %>
<%= highlight "5,8~10" %>


Next, we'll clear errors in the router so that navigating to another page will make these errors vanish forever:
　次に、私たちは　ルーターでエラーをクリアします　（ so that？）　他のページに（navigating？）　は　エラーを永遠に消します。　

~~~js
// ...

Router.before(requireLogin, {only: 'postSubmit'})
Router.before(function() { clearErrors() });
~~~
<%= caption "lib/router.js" %>
<%= highlight "4" %>


In order for our clearErrors() function to do its job, errors need to be marked as seen.
To do this properly, there's one edge case we need to take care of: 
when we throw up an error and then redirect the user somewhere else (as we do when they try to post a duplicate link), 
the redirection happens instantly.
This means that the user never has the chance to actually see the error before it's cleared.
　clearErrors() 関数に仕事をさせるために、（errors？）は（ seen？）にマークされている必要があります。
　正しく行うために、　対処する必要のある（ one edge case ？）があります。：
　私たちがエラーを（ throw up？）して、（somewhere else？）にユーザーをリダイレクトする時（as we do when they try to post a duplicate link？）、
　リダイレクトは瞬時に行われます。
　つまり、エラーがクリアされる前に、ユーザーは実際にエラーを見るチャンスがないということです。


This is where our seen property will come in handy.
We need to ensure that it's only set to true if the user has actually seen the error.
　これが　（seen？）プロパティが（ come in handy？）する場所です。（？？？）
　私たちはユーザーが実際にエラーを見た場合に、確実にtrueとだけセットする必要があります。（？？？）　

To achieve this, we'll use Meteor.defer().
This function tells Meteor to execute its callback "just after" whatever's going on now.
If it helps, you can consider that defer() is like telling the browser to wait 1 millisecond before proceeding.
　このようにするために、Meteor.defer()を使います。
　この関数はMeteorに　（ "just after" whatever's going on now？）コールバックを実行する命令をします。
　（If it helps？）、defer()は　ブラウザーに　（ proceeding？）する前に、（1 millisecond？）待つように命令している　と考えることができます。






Template.errors.helpers({

~~~js
Template.errors.helpers({
  errors: function() {
    return Errors.find();
  }
});

Template.error.rendered = function() {
  var error = this.data;
  Meteor.defer(function() {
    Errors.update(error._id, {$set: {seen: true}});
  });
};
~~~
<%= caption "client/views/includes/errors.js" %>
<%= highlight "7~12" %>

<%= commit "9-3", "Monitor which errors have been seen, and clear on routing." %>



What we're doing is telling Meteor to set seen to true 1 millisecond after the errors template has been rendered.
But remember how we said that redirection happens instantly?
This means that the redirection will kick in before the defer callback, 
which will never have a chance to be executed.
　私たちがしていることは、errorsテンプレートがレンダリングされた後で
　（set seen to true 1 millisecond ？＝seenを1秒間にtrueとセットする？）
　ことを　Meteorに指示を出しています。
　しかし、　私たちはどのように（redirection？）が瞬時に起こすと言ったのか（？？？）思い出して下さい。
　これは　deferコールバックの後で（ redirection？）が（ kick in ）するということで、
　実行されることはありません。

This is exactly what we want: 
if it's not executed our error will not be marked as seen, 
which means it won't be cleared, 
which means it'll appear on the page our user is redirected to just like we wanted!
 　これはまさに私たちが望んだことです。
　（it？）が実行されない場合、エラーは（ seen？）とマークされません。
　これは（it？）がクリアされないということで、
　ユーザーがリダイレクトされたページに現れる　　私たちが望んでいたように　（？？？）

<% note do %>

### The `rendered` callback


The rendered callback triggers once our template has been rendered in the browser. 
Inside the callback, this refers to the current template instance, 
and this.data lets us access the data of the object that is currently being rendered (in our case, an error).
　レンダリングされたコールバックはブラウザーでレンダリングされたテンプレートを
（ trigger？）します。
　コールバックの中で、　this　は現在のテンプレートインスタンスを参照するので、
　私たちは　this.data　で現在レンダリングされているオブジェクトのデータに　アクセスすることができます。　

Whew! That was a lot of work for something users will hopefully never see!
　ふう！　ユーザーが　見ないようにするのは　大仕事でしたね！

<% end %>
